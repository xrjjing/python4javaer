# 09_RBAC_用户认证与权限（FastAPI + SQLAlchemy + JWT + Redis 可选）

> 目标：在前面 TODO API 和 Java 服务网关的基础上，实现一套「用户 / 角色 / 权限」的完整 RBAC 示例，学习如何在 Python Web 服务中落地认证与授权。

## 一、项目定位

- 技术栈：
  - Web 框架：FastAPI
  - ORM：SQLAlchemy 2.x 风格
  - 数据库：默认 SQLite，方便本地演示（可通过配置切换到 MySQL）
  - 认证：JWT（基于 OAuth2 Password 流）
  - 权限：RBAC（Role-Based Access Control，角色 + 权限码）
  - 缓存：可选 Redis（用于 Token 黑名单或权限缓存）

- 功能目标：
  1. 用户注册 / 登录，获得 JWT 访问令牌；
  2. 支持用户 → 角色 → 权限多对多关系；
  3. 支持基于角色 / 权限的接口访问控制；
  4. 提供少量管理接口：管理用户、角色、权限；
  5. 提供一个受 RBAC 控制的 TODO API（仅具备相应权限的用户可访问）。

> 注意：本项目更侧重「架构和代码结构」而非复杂 UI 展示，主要通过 Swagger UI / curl / HTTP 客户端进行调试，同时提供一个轻量级的 Web 控制台（rbac_admin.html）方便交互体验。

---

## 二、目录结构（已实现）

```text
rbac_auth_service/
├── 09_项目说明.md                 # 本文档
├── app/
│   ├── __init__.py
│   ├── main.py                    # FastAPI 应用入口（挂载 /rbac-admin 静态控制台）
│   ├── config.py                  # 配置模块（DATABASE_URL / REDIS_URL / SECRET_KEY 等）
│   ├── database.py                # 数据库引擎与 Session 管理（SQLite / MySQL）
│   ├── models.py                  # 用户 / 角色 / 权限 / Todo / Project / Task ORM 模型
│   ├── schemas.py                 # Pydantic 模型（输入 / 输出 + 统一响应）
│   ├── security.py                # 密码哈希、JWT 生成与验证、Redis Token 黑名单
│   ├── dependencies.py            # 通用依赖（DB 会话、当前用户、RBAC 检查）
│   ├── repositories/              # Repository 层：持久化操作
│   ├── services/                  # Service 层：业务逻辑（用户 / 角色 / RBAC / Todo / Project / Task）
│   ├── routers/                   # 路由层：暴露 HTTP API
│   │   ├── auth.py                # 登录 / 获取当前用户 / 登出（支持 Token 黑名单）
│   │   ├── users.py               # 用户管理（仅 admin）
│   │   ├── roles.py               # 角色与权限管理
│   │   ├── todos.py               # 受 RBAC 控制的 TODO 示例
│   │   ├── projects.py            # Project 业务域示例
│   │   └── tasks.py               # Task 子资源（挂在 Project 下）
│   └── static/
│       └── rbac_admin.html        # RBAC 管理控制台前端页面（纯 HTML + JS）
└── test_rbac_api.py               # 基础接口测试（登录 + 权限控制）
```

后续会按章节逐步完善上述文件结构，并在文档中补充对应讲解。

---

## 三、RBAC 模型设计

### 1. 核心实体

- 用户（User）
  - 字段：id, username, hashed_password, is_active, is_superuser, created_at, updated_at
  - 关系：多对多角色（roles）
- 角色（Role）
  - 字段：id, name, description
  - 关系：多对多用户、多对多权限
- 权限（Permission）
  - 字段：id, code, name, description
  - 说明：`code` 为唯一标识，例如 `todos:read`, `todos:write`, `users:manage`
- TODO（Todo）
  - 字段：id, title, completed, owner_id
  - 说明：示例业务实体，用来演示 RBAC 控制

关系表：

- user_roles：user_id ↔ role_id
- role_permissions：role_id ↔ permission_id

### 2. 权限检查方式

- 获取当前用户时，从数据库加载其角色及权限；
- RBAC 检查通过 FastAPI 依赖（Depends）实现：
  - `require_roles("admin")`
  - `require_permissions("todos:read")`

依赖会在请求进入路由前执行，若检查不通过，则返回 403 Forbidden。

---

## 四、JWT 与 Redis 设计（概要）

### 1. JWT 载荷（Payload）

示例字段：

- `sub`: 用户 ID
- `username`: 用户名
- `is_superuser`: 是否超级管理员
- `exp`: 过期时间
- `jti`: Token 唯一 ID（用于黑名单）

> 说明：权限列表/角色列表不一定要塞进 Token，可以根据需要做折中（本示例以「从数据库查询」为主，Redis 缓存为可选优化）。

### 2. Redis 的使用方式（Token 黑名单，可选）

- 若配置了 `REDIS_URL` 且安装了 `redis` 依赖：
  - `security.TokenBlacklist` 会使用 Redis 存储被登出的 Token 的 `jti`；
  - 每次通过 `get_current_user` 校验 Token 时，都会检查是否在黑名单中；
  - 适合多实例部署或需要统一登出场景。
- 若未配置 `REDIS_URL` 或未安装 `redis` 包：
  - 自动退化为进程内 `set` 存储，仅适合本地单进程演示。

你可以在本地用 Redis 验证登出效果，也可以暂时不配置，完全不影响示例跑通。

---

## 五、运行方式与配置示例

### 1. 配置说明

配置由 `app/config.py` 中的 `Settings` 管理，支持 `.env` 文件和环境变量覆盖，常用字段：

- `DATABASE_URL`（database_url）：
  - 默认：`sqlite:///./rbac.db`
  - MySQL 示例：`mysql+pymysql://user:password@localhost:3306/yourdb`
- `REDIS_URL`（redis_url）：
  - 示例：`redis://localhost:6379/0`
- `SECRET_KEY`（secret_key）：
  - 用于签发 JWT 的密钥，生产环境必须改成随机值。
- `ACCESS_TOKEN_EXPIRE_MINUTES`（access_token_expire_minutes）：
  - 访问 Token 的过期时间，单位分钟，默认 60。

你可以选择两种方式配置：

1. 使用环境变量；
2. 在项目根目录（`rbac_auth_service`）下创建 `.env` 文件。

示例 `.env`：

```env
DATABASE_URL=sqlite:///./rbac.db
# DATABASE_URL=mysql+pymysql://user:password@localhost:3306/yourdb
REDIS_URL=redis://localhost:6379/0
SECRET_KEY=please-change-me
ACCESS_TOKEN_EXPIRE_MINUTES=60
```

### 2. 运行 FastAPI 应用

```bash
cd rbac_auth_service

# 可选：使用环境变量配置数据库和 Redis
export DATABASE_URL=\"sqlite:///./rbac.db\"   # 或 MySQL 连接串
export SECRET_KEY=\"your-secret-key\"
export REDIS_URL=\"redis://localhost:6379/0\"  # 可选启用 Redis 黑名单

uvicorn app.main:app --reload
```

启动后访问：

- Swagger UI：`http://127.0.0.1:8000/docs`
- ReDoc：`http://127.0.0.1:8000/redoc`

---

### 3. 使用 MySQL + Redis 的完整步骤示例

以下给出一个从“空库 + 空 Redis”到“服务跑起来”的参考流程，你可以对照自己的环境做调整：

1. **在 MySQL 中创建数据库**
   - 例如：
     ```sql
     CREATE DATABASE rbac_demo CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
     ```
   - 准备好用户和密码，例如：`rbac_user / rbac_pass`。

2. **安装依赖**
   - 在虚拟环境中安装 MySQL 驱动与 Redis 客户端：
     ```bash
     pip install "pymysql" redis
     ```

3. **配置 `.env`（推荐）**
   - 在 `rbac_auth_service` 目录下创建 `.env`：
     ```env
     DATABASE_URL=mysql+pymysql://rbac_user:rbac_pass@localhost:3306/rbac_demo
     REDIS_URL=redis://localhost:6379/0
     SECRET_KEY=please-change-me-to-a-random-secret
     ACCESS_TOKEN_EXPIRE_MINUTES=60
     ```
   - 根据你的实际主机/端口/库名/账号密码调整连接串。

4. **初始化表结构和基础数据**
   - 在同一目录下执行：
     ```bash
     python init_rbac_data.py
     ```
   - 这一步会：
     - 使用 `DATABASE_URL` 连接 MySQL 并创建所有表；
     - 插入 admin / alice / 角色 / 权限等初始数据。

5. **启动 FastAPI 服务**
   - 使用 uvicorn 启动：
     ```bash
     uvicorn app.main:app --reload
     ```
   - 访问 `/docs`，用 Swagger UI 调试登录、项目、任务等接口。

6. **验证 Redis Token 黑名单（可选）**
   - 确保 Redis 可用并已配置 `REDIS_URL`；
   - 流程：
     1. 调 `/auth/login` 获取 Token；
     2. 带上 `Authorization: Bearer <token>` 调几个受保护接口（例如 `/projects/`）；
     3. 调 `/auth/logout`；
     4. 再次使用同一个 Token 调接口，应返回 401，表示黑名单生效。

---

## 六、初始化基础数据

为方便快速体验 RBAC 行为，本项目提供了一个初始化脚本：

```bash
cd rbac_auth_service
python init_rbac_data.py
```

默认会创建：

- 超级管理员：`admin / admin123`
- 普通用户：`alice / alice123`
- 角色：
  - `admin`：拥有所有示例资源的读/写/删权限
  - `user`：拥有部分读/写权限（无删权限）
- 权限（与 `init_rbac_data.py` 保持一致）：
  - `todos:read`、`todos:write`、`todos:delete`
  - `projects:read`、`projects:write`、`projects:delete`
  - `tasks:read`、`tasks:write`、`tasks:delete`

你可以通过环境变量覆盖默认用户名和密码：

- `ADMIN_USERNAME` / `ADMIN_PASSWORD`
- `NORMAL_USERNAME` / `NORMAL_PASSWORD`

---

## 七、RBAC 管理控制台（rbac_admin.html）

除了 Swagger UI 与 API 测试脚本，本项目还提供了一个纯前端的 RBAC 管理控制台页面，便于你「点一下就能看到效果」。

### 1. 访问方式

1. 启动应用：

   ```bash
   cd rbac_auth_service
   uvicorn app.main:app --reload
   ```

2. 浏览器访问：

   - 控制台入口：`http://127.0.0.1:8000/rbac-admin/rbac_admin.html`
   - 或在总入口 `frontend/index.html` 中选择「RBAC 权限服务与控制台」章节，点击「打开 RBAC 管理控制台」按钮（会在新标签页打开同一地址）。

### 2. 控制台与后端接口的对应关系

控制台本质是一个单页 HTML + 原生 JS 应用，所有数据都来自本服务提供的 REST API：

- 认证与会话
  - 表单：用户名 + 密码（默认 admin / admin123、alice / alice123）
  - 接口映射：
    - 「登录」按钮 → `POST /auth/login`（OAuth2 Password 表单）
    - 「登出」按钮 → `POST /auth/logout`
    - 「快速查看 /auth/me」 → `GET /auth/me`
  - 说明：登录成功后，返回的 `access_token` 会缓存在前端内存，并自动附加到后续请求的 `Authorization: Bearer <token>` 头中。

- 当前用户信息
  - 按钮：「获取 /auth/me」
  - 接口映射：`GET /auth/me`
  - 输出：使用统一响应模型 `APIResponse[UserOut]`，展示 id / username / is_superuser / roles。

- 角色与权限管理
  - 左侧为「角色管理」表单：
    - 新角色名称 + 描述 → 「创建角色」按钮
    - 接口映射：`POST /rbac/roles`，请求体为 `RoleCreate`（`{"name": str, "description": str | null}`）
  - 右侧为「权限管理」表单：
    - 权限 code + 名称 + 描述 → 「创建权限」按钮
    - 接口映射：`POST /rbac/permissions`，请求体为 `PermissionCreate`（`{"code": str, "name": str, "description": str | null}`）
  - 角色-权限矩阵：
    - 「列出角色列表」按钮 → `GET /rbac/roles`
    - 同时会自动调用：`GET /rbac/permissions`
    - 前端根据两个接口返回的 `RoleOut.permissions` 和 `PermissionOut` 构建「角色 × 权限码」矩阵：
      - 行：角色（完全来自 RoleOut）
      - 列：权限（完全来自 PermissionOut）
      - 勾选状态：由 `role.permissions` 中是否包含对应 `permission.id` 决定
    - 每行「保存」按钮：
      - 收集该行所有被勾选的权限 ID，调用：
        - `POST /rbac/roles/{role_id}/permissions`
        - 请求体：`{"permission_ids": [int, ...]}`（与后端 `AssignPermissionsRequest` 模型一致）

- 用户管理（只读）
  - 按钮：「列出用户列表」
  - 接口映射：`GET /users/`
  - 说明：目前控制台只做「只读展示」，写操作（创建用户、分配角色）保留给 API/代码练习使用。

- 示例资源
  - 按钮与接口映射：
    - `GET /todos/` → 受 `todos:read` 权限保护
    - `GET /projects/` → 受 `projects:read` 权限保护
    - `GET /projects/{id}/tasks/` → 受 `tasks:read` 权限保护
  - 用法：用 admin / alice 分别登录，点击这些按钮，就能直观看到不同权限集带来的访问差异（200 / 403）。

### 3. 建议练习路径（配合控制台）

1. 使用初始化脚本创建 admin / alice 及基础角色权限；
2. 在控制台中用 admin 登录，体验：
   - 查看当前用户信息；
   - 列出用户 / 角色 / 权限；
   - 使用矩阵为 `user` 角色增加或移除权限；
3. 切换为 alice 登录，重复访问「示例资源」区域，观察 403 的变化；
4. 尝试新增一组业务权限（例如 `courses:read` / `courses:write`），并通过矩阵将其分配给新建角色，再在后端添加对应受控接口，形成完整闭环。
