# 08_系统对接_调用 Java 服务 API

> 目标：模拟一个典型场景——现有核心系统由 Java 编写，对外提供 HTTP/JSON 接口；我们用 Python 写一个「边车服务」或「工具服务」，通过调用 Java 接口完成业务逻辑。练习 HTTP 客户端、配置管理、错误处理与重试等。

## 1. 项目背景

在真实工作中，常见的组合是：

- 核心交易 / 订单 / 账务系统由 Java（Spring Boot 等）实现；
- 需要写一些辅助服务或工具：
  - 对接第三方平台；
  - 做数据同步、报表导出；
  - 给内部运营/测试提供一些特殊接口。

这些辅助服务非常适合用 Python + FastAPI 编写，然后通过 HTTP 调用 Java 系统暴露的 REST 接口。

本项目就是围绕「Python 调用 Java 服务」展开。

## 2. 目录与文件说明

```text
03.项目实战/
└── 08_系统对接_调用Java服务API/
    ├── 08_项目说明.md
    ├── client_java_service.py      # 封装 Java 服务调用的客户端
    └── api_gateway_example.py     # 使用 FastAPI 封装一层网关示例
```

说明：

- `client_java_service.py`：模拟一个访问 Java 系统的 HTTP 客户端，包含：
  - 读取环境变量或配置文件中的 Java 服务 `BASE_URL`；
  - 封装 GET/POST 请求、超时设置、错误处理；
  - 提供高层方法如 `get_user()`、`create_order()`。
- `api_gateway_example.py`：示例如何用 FastAPI 包一层，把 Java 接口「翻译」成内部统一风格的接口。

> 由于你本地的 Java 系统地址和接口规范是私有的，本项目代码以「可配置 + 示例」为主，你可以根据自己公司的接口文档进行适配。

## 3. 运行方式（示意）

假设 Java 服务对外提供：

- `GET http://localhost:8080/api/users/{user_id}` 返回用户信息；
- `POST http://localhost:8080/api/orders` 创建订单。

你可以：

1. 设置环境变量（或在代码里直接写死 base_url，用于学习阶段）：

   ```bash
   export JAVA_SERVICE_BASE_URL="http://localhost:8080"
   ```

2. 运行 FastAPI 网关示例：

   ```bash
   pip install fastapi "uvicorn[standard]" requests
   cd 03.项目实战/08_系统对接_调用Java服务API
   uvicorn api_gateway_example:app --reload
   ```

3. 打开 `http://127.0.0.1:8000/docs` 试用：

   - `GET /proxy/users/{user_id}` → 转发到 Java 的 `/api/users/{user_id}`；
   - `POST /proxy/orders` → 转发到 Java 的 `/api/orders`。

## 4. 通用网关响应模板（code/message/data）

为了方便前端或调用方统一处理结果，`api_gateway_example.py` 中定义了一个通用响应模型：

```python
class ApiResponse(BaseModel):
    code: int = 0
    message: str = "ok"
    data: Any | None = None
```

约定：

- 成功场景：
  - HTTP 状态码为 200；
  - `code = 0`，`message = "ok"`；
  - `data` 中存放具体业务数据（例如用户信息、订单信息）。
- 失败场景：
  - 为了保留 HTTP 语义，仍然使用 4xx / 5xx 状态码 + FastAPI 默认的
    `{"detail": "..."}` 结构；
  - 例如当 Java 服务返回 5xx 或抛出异常时，网关返回 502 + detail。

示例（创建订单成功返回）：

```json
{
  "code": 0,
  "message": "ok",
  "data": {
    "id": 123,
    "user_id": 1,
    "amount": 99.5
  }
}
```

你可以在自己的项目中复用这一模式：将所有「成功响应」统一包裹在 `ApiResponse` 中，而错误仍交给 HTTP 状态码表达。

## 5. 测试说明

- 本项目建议补两类测试：
  - 针对 `JavaServiceClient` 内部行为的单元测试（例如 `_handle_response` 如何处理成功 / 失败响应）；
  - 针对 FastAPI 网关接口的集成测试（使用 `TestClient` 调用 `/proxy/...` 接口，验证异常转换逻辑）。
- 本仓库已在本目录下提供参考测试文件：
  - `test_client_java_service.py`：只测客户端，不跑 FastAPI；
  - `test_api_gateway_example.py`：使用 Fake 客户端 + `TestClient` 测试 FastAPI 网关；
  - 你也可以参考 `03_TODO_Web_API_FastAPI/test_todo_api.py` 的写法拓展更多场景。

  ```bash
  pytest 03.项目实战/08_系统对接_调用Java服务API
  ```

常见测试点示例：

- 模拟 Java 返回 5xx 状态码，检查是否抛出 `JavaServiceError` 并在网关层被转换为 HTTP 502；
- 模拟 Java 返回格式异常（不是 JSON 或字段缺失），检查是否抛出统一的「返回格式异常」类错误；
- 使用 FastAPI 的依赖注入重载，将 `get_java_client` 替换为一个 Fake 客户端，避免在测试时真实调用 Java 服务。

## 4. 扩展练习

- 根据你真实的 Java 接口文档，修改 `JavaServiceClient` 中的路径、请求体和响应模型定义；
- 实现统一错误处理：将 Java 返回的错误码 / 错误信息转换为统一的 Python API 错误格式；
- 为客户端增加简单重试逻辑（例如网络抖动时自动重试一次 GET 请求）；
- 在 FastAPI 层增加简单的权限校验或请求日志记录。
