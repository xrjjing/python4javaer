# 03.项目实战

> 目标：在掌握基础语法和开发环境之后，通过从易到难的项目梯度，快速积累「能解决真实问题」的 Python 开发经验。

你可以把本目录理解为「实战路线图」：  
每一个项目都对应一个具体场景，包含：项目目标、功能拆分、代码结构建议、关键示例代码、可选扩展任务。

---

## 项目梯度总览

建议按照难度从上到下依次完成，每个项目都可以单独放在 `03.项目实战` 下自己的子目录。

1. `01_命令行工具_批量重命名文件`  
   - 难度：⭐️  
   - 练习点：文件操作、循环、字符串处理、简单参数。

2. `02_日志分析与报表生成`  
   - 难度：⭐️⭐️  
   - 练习点：文件读写、正则 / 字符串解析、字典统计、简单报表输出。

3. `03_TODO_Web_API_FastAPI`  
   - 难度：⭐️⭐️⭐️  
   - 练习点：FastAPI 路由、请求/响应模型、简单持久化（内存 → 文件 / 数据库）。

4. `04_小型数据分析项目_销售统计`  
   - 难度：⭐️⭐️⭐️  
   - 练习点：pandas 数据处理、汇总统计、图表可视化（可选）。

5. `05_简单爬虫_新闻标题抓取`  
   - 难度：⭐️⭐️  
   - 练习点：HTTP 请求、HTML 解析、数据清洗、合法合规爬虫意识。

6. `06_自动化脚本_日志归档`  
   - 难度：⭐️⭐️  
   - 练习点：文件系统操作、时间计算、压缩归档、自动化运维思路。

7. `07_监控数据处理_指标聚合与告警`  
   - 难度：⭐️⭐️⭐️  
   - 练习点：CSV 解析、聚合统计、简单规则引擎、与监控系统的衔接思维。

8. `08_系统对接_调用Java服务API`  
   - 难度：⭐️⭐️⭐️  
   - 练习点：HTTP 客户端封装、错误处理、FastAPI 网关、与 Java 系统集成。

---

## 按工作场景的项目视图

如果从「工作场景」而不是「技术点」来分类，大致可以分为四组，你可以针对自己当前的工作重点优先练某一组：

- **A. 写接口（API 开发与网关）**
  - `03_TODO_Web_API_FastAPI`：自己实现业务接口（TODO 管理）。
  - `08_系统对接_调用Java服务API`：Python 网关调用 Java 系统的 HTTP 接口。
  - 入口说明：`A_写接口_接口开发与网关/01_写接口_接口开发与网关.md`

- **B. 做 batch / 定时任务**
  - `06_自动化脚本_日志归档`：夜间归档日志。
  - `04_小型数据分析项目_销售统计`：日终跑报表。
  - 入口说明：`B_批处理任务_定时与脚本/02_批处理任务_定时与脚本.md`

- **C. 分析日志 / 监控**
  - `02_日志分析与报表生成`：基础日志统计。
  - `07_监控数据处理_指标聚合与告警`：监控指标聚合与阈值告警。
  - 入口说明：`C_日志分析_排障与报表/03_日志分析_排障与报表.md`

- **D. 对接其他系统（内部 / 第三方）**
  - `05_简单爬虫_新闻标题抓取`：对接公开 Web 网站的页面抓取。
  - `08_系统对接_调用Java服务API`：对接内部 Java 系统的 REST API。
  - 入口说明：`D_系统对接_内部与第三方/04_系统对接_内部与第三方.md`

> 提示：你完全可以在未来继续向下扩展新的项目目录，比如：爬虫、自动化脚本、监控数据处理等。

---

## 关于本目录的测试（pytest）

为了让每个项目的用法和行为更清晰，本目录下部分项目已经补充了配套的 `pytest` 测试文件，例如：

- `03.项目实战/01_命令行工具_批量重命名文件/test_rename_files.py`
- `03.项目实战/02_日志分析与报表生成/test_log_analyzer.py`
- `03.项目实战/03_TODO_Web_API_FastAPI/test_todo_api.py`
- `03.项目实战/04_小型数据分析项目_销售统计/test_analyze_sales.py`
- `03.项目实战/05_简单爬虫_新闻标题抓取/test_crawler_news_titles.py`
- `03.项目实战/06_自动化脚本_日志归档/test_archive_old_logs.py`
- `03.项目实战/07_监控数据处理_指标聚合与告警/test_process_metrics.py`

在仓库根目录安装好 `pytest` 之后，你可以：

- 一次性运行本目录所有测试：

  ```bash
  pytest 03.项目实战
  ```

- 或者只针对某个项目运行测试（例如 TODO Web API）：

  ```bash
  pytest 03.项目实战/03_TODO_Web_API_FastAPI/test_todo_api.py
  ```

建议你在修改或扩展这些项目之前，先阅读对应的 `test_*.py` 文件，会比直接看主脚本更容易理解「这个项目的核心用法」。

---

## 01_命令行工具_批量重命名文件

### 1. 项目目标

实现一个命令行工具，对指定目录下的文件进行批量重命名，例如：

- 给文件名统一加前缀 / 后缀
- 替换文件名中的某个子串
- 按编号顺序重命名（`001_xxx.ext`、`002_xxx.ext`）

### 2. 目录与文件建议

```text
03.项目实战/
└── 01_命令行工具_批量重命名文件/
    ├── 01_项目说明.md
    └── rename_files.py
```

### 3. 核心示例代码

```python
# 03.项目实战/01_命令行工具_批量重命名文件/rename_files.py

import argparse
from pathlib import Path


def rename_files(
    directory: Path,
    prefix: str | None = None,
    suffix: str | None = None,
) -> None:
    if not directory.is_dir():
        raise ValueError(f"目录不存在：{directory}")

    for idx, path in enumerate(sorted(directory.iterdir()), start=1):
        if not path.is_file():
            continue
        stem = path.stem
        new_stem = stem
        if prefix:
            new_stem = prefix + new_stem
        if suffix:
            new_stem = new_stem + suffix

        new_name = f"{idx:03d}_{new_stem}{path.suffix}"
        new_path = path.with_name(new_name)
        print(f"{path.name} -> {new_path.name}")
        path.rename(new_path)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="批量重命名目录中的文件")
    parser.add_argument("directory", help="目标目录路径")
    parser.add_argument("--prefix", help="文件名前缀", default="")
    parser.add_argument("--suffix", help="文件名后缀", default="")
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    dir_path = Path(args.directory)
    rename_files(dir_path, prefix=args.prefix or None, suffix=args.suffix or None)


if __name__ == "__main__":
    main()
```

运行示例：

```bash
python 03.项目实战/01_命令行工具_批量重命名文件/rename_files.py ./some_dir --prefix img_ --suffix _v1
```

### 4. 建议的扩展练习

- 增加「模拟模式」，先只打印将要重命名的结果，不实际改名。
- 增加过滤条件，只重命名某些扩展名（如 `.jpg`、`.png`）。
- 给工具增加简单的日志输出（写入到 log 文件）。

---

## 02_日志分析与报表生成

### 1. 项目目标

解析一份应用日志（或 Web 访问日志），统计一些有用的信息，例如：

- 每种日志级别（INFO/WARN/ERROR）的数量
- 每天的错误次数
- 某个关键字出现次数

### 2. 目录与文件建议

```text
03.项目实战/
└── 02_日志分析与报表生成/
    ├── 02_项目说明.md
    ├── sample.log          # 示例日志
    └── log_analyzer.py
```

### 3. 核心示例代码（简化版）

```python
# 03.项目实战/02_日志分析与报表生成/log_analyzer.py

from collections import Counter
from pathlib import Path


def analyze_log(path: Path) -> None:
    level_counter: Counter[str] = Counter()

    with path.open("r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            # 简单假设：一行日志类似 "2025-01-01 12:00:00 [INFO] message..."
            if "[" in line and "]" in line:
                level = line.split("[", 1)[1].split("]", 1)[0]
                level_counter[level] += 1

    print("按日志级别统计：")
    for level, count in level_counter.most_common():
        print(f"{level}: {count}")


def main() -> None:
    log_path = Path("sample.log")
    if not log_path.exists():
        print("请先准备 sample.log 文件")
        return
    analyze_log(log_path)


if __name__ == "__main__":
    main()
```

### 4. 建议的扩展练习

- 使用命令行参数指定日志路径和要统计的关键字。  
- 输出更详细的报表到 `report.txt`，如每小时的错误数量。  
- 使用 `pandas` 读取结构化日志（如 CSV），做更复杂的统计。  
- 将结果绘制成简单的图表（结合 `matplotlib`）。  

---

## 03_TODO_Web_API_FastAPI

### 1. 项目目标

实现一个简单的 TODO 管理 REST API，包括：

- 创建 TODO
- 查询所有 TODO
- 更新 TODO 状态（完成 / 未完成）
- 删除 TODO

### 2. 目录与文件建议

```text
03.项目实战/
└── 03_TODO_Web_API_FastAPI/
    ├── 03_项目说明.md
    └── app/
        ├── __init__.py
        └── main.py
```

### 3. FastAPI 核心示例代码

```python
# 03.项目实战/03_TODO_Web_API_FastAPI/app/main.py

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List


class Todo(BaseModel):
    id: int
    title: str
    completed: bool = False


class TodoCreate(BaseModel):
    title: str


app = FastAPI()

_todos: List[Todo] = []
_next_id = 1


@app.get("/todos", response_model=List[Todo])
def list_todos():
    return _todos


@app.post("/todos", response_model=Todo)
def create_todo(todo_in: TodoCreate):
    global _next_id
    todo = Todo(id=_next_id, title=todo_in.title)
    _next_id += 1
    _todos.append(todo)
    return todo


@app.put("/todos/{todo_id}", response_model=Todo)
def update_todo(todo_id: int, completed: bool):
    for todo in _todos:
        if todo.id == todo_id:
            todo.completed = completed
            return todo
    raise HTTPException(status_code=404, detail="Todo not found")


@app.delete("/todos/{todo_id}")
def delete_todo(todo_id: int):
    global _todos
    _todos = [t for t in _todos if t.id != todo_id]
    return {"deleted": True}
```

运行方式：

```bash
pip install fastapi "uvicorn[standard]"
cd 03.项目实战/03_TODO_Web_API_FastAPI
uvicorn app.main:app --reload
```

浏览器访问：`/docs` 可直接测试接口。

### 4. 建议的扩展练习

- 将内存存储改为写入 JSON 文件，实现简单持久化。  
- 给 TODO 增加 `created_at` 字段，并按创建时间排序返回。  
- 增加简单的用户系统（只支持一个固定用户也可以），区分不同用户的 TODO。  

---

## 04_小型数据分析项目_销售统计

### 1. 项目目标

从一份销售记录 CSV 文件中，完成以下任务：

- 计算总销售额
- 按商品统计销量和销售额
- 按日期 / 月份统计销售趋势

### 2. 目录与文件建议

```text
03.项目实战/
└── 04_小型数据分析项目_销售统计/
    ├── 04_项目说明.md
    ├── sales.csv
    └── analyze_sales.py
```

### 3. 核心示例代码（pandas 版）

```python
# 03.项目实战/04_小型数据分析项目_销售统计/analyze_sales.py

import pandas as pd


def main():
    df = pd.read_csv("sales.csv")

    # 假设包含列：date, product, quantity, price
    df["amount"] = df["quantity"] * df["price"]

    print("总销售额：", df["amount"].sum())

    print("\n按商品统计：")
    by_product = df.groupby("product")["amount"].sum().sort_values(ascending=False)
    print(by_product)

    print("\n按日期统计：")
    df["date"] = pd.to_datetime(df["date"])
    by_day = df.groupby("date")["amount"].sum()
    print(by_day)


if __name__ == "__main__":
    main()
```

### 4. 建议的扩展练习

- 用 `matplotlib` 将每天的销售额画成折线图。  
- 将分析结果导出到新的 CSV 或 Excel 文件中。  
- 结合第 2 个项目（日志分析）思路，设计你自己的指标（例如：Top N 商品、工作日与周末对比等）。  

---

## 如何使用本目录

- 当你完成 `01.Python语言基础` 的主要章节后：  
  1. 先做「01_命令行工具」和「02_日志分析」，巩固语法与文件操作。  
  2. 再选择 Web 或数据方向的项目（或两个都做）。  
- 每个项目建议用 Git 单独开分支或至少多写些 commit，保留你的探索过程，方便以后回顾。  

遇到任何一个项目中的具体问题时，你可以直接告诉我：  
「我在 `03.项目实战/03_TODO_Web_API_FastAPI` 的 XXX 部分遇到了问题」，我会结合目录结构和代码帮你一起排查。  
