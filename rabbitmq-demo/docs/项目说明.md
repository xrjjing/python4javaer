# RabbitMQ 消息队列实战 - 项目说明

## 项目概述

本项目是 Python 学习平台的 RabbitMQ 消息队列实战教学案例，通过完整的生产者/消费者模式演示，帮助学习者理解消息队列的核心概念和实际应用。

## 学习目标

通过本项目，你将学习到：

1. **消息队列基础概念**
   - 什么是消息队列
   - 生产者（Producer）和消费者（Consumer）模式
   - 队列（Queue）的作用和特性

2. **RabbitMQ 核心知识**
   - RabbitMQ 的安装和配置
   - Connection 和 Channel 的概念
   - 消息的发送和接收
   - 队列的声明和管理

3. **Python 实战技能**
   - 使用 pika 库操作 RabbitMQ
   - FastAPI 构建 REST API
   - 前后端分离架构
   - Mock 模式和真实模式的切换

4. **Docker 容器化**
   - 使用 Docker Compose 部署 RabbitMQ
   - 容器化应用的配置和管理

## 项目架构

### 整体架构

```
┌─────────────┐      HTTP      ┌──────────────┐      AMQP      ┌──────────────┐
│   前端页面   │ ────────────> │  FastAPI 后端 │ ────────────> │   RabbitMQ   │
│  (Browser)  │                │   (Python)   │                │   (Docker)   │
└─────────────┘                └──────────────┘                └──────────────┘
```

### 目录结构

```
rabbitmq-demo/
├── backend/                    # 后端服务
│   ├── app/
│   │   ├── main.py            # FastAPI 应用入口
│   │   ├── api/               # API 路由
│   │   │   └── routes/
│   │   │       ├── queues.py  # 队列操作 API
│   │   │       └── health.py  # 健康检查 API
│   │   ├── core/              # 核心配置
│   │   │   ├── config.py      # 配置管理
│   │   │   └── rabbit.py      # RabbitMQ 连接管理
│   │   └── services/          # 业务逻辑
│   │       └── queue_client.py # 队列客户端抽象
│   ├── requirements.txt       # Python 依赖
│   └── .env                   # 环境变量配置
├── frontend/                  # 前端页面
│   └── index.html            # 主页面（含 Mock 和 Real 模式）
├── docker-compose.yml        # RabbitMQ Docker 配置
├── README.md                 # 快速开始指南
└── docs/
    └── 项目说明.md           # 详细项目说明（本文档）
```

## 核心功能

### 1. 双模式支持

#### Mock 模式（离线演示）
- **特点**：无需启动 RabbitMQ 和后端服务
- **实现**：前端使用内存队列模拟消息收发
- **适用场景**：快速演示、离线学习、理解概念

#### Real 模式（真实连接）
- **特点**：连接真实的 RabbitMQ 服务
- **实现**：后端通过 pika 库与 RabbitMQ 通信
- **适用场景**：实战练习、完整体验、生产环境模拟

### 2. 生产者功能

- 发送消息到指定队列
- 支持自定义队列名称
- 支持自定义消息内容
- 实时反馈发送状态

### 3. 消费者功能

- 实时接收队列中的消息
- 显示消息内容和时间戳
- 自动滚动显示最新消息
- 消息列表动画效果

### 4. 队列监控

- 队列中的消息数量
- 消费者数量统计
- 已接收消息计数
- 实时更新统计数据

## 技术栈

### 后端
- **FastAPI**: 现代、快速的 Python Web 框架
- **pika**: RabbitMQ 的 Python 客户端库
- **pydantic**: 数据验证和设置管理
- **uvicorn**: ASGI 服务器

### 前端
- **HTML5 + CSS3**: 现代 Web 标准
- **JavaScript (ES6+)**: 原生 JavaScript，无框架依赖
- **Fetch API**: 异步 HTTP 请求

### 基础设施
- **RabbitMQ 3**: 消息队列服务
- **Docker**: 容器化部署
- **Docker Compose**: 多容器编排

## 使用指南

### 前置要求

- Python 3.8+
- Docker 和 Docker Compose
- 现代浏览器（Chrome、Firefox、Safari 等）

### 快速开始

#### 1. 启动 RabbitMQ（Docker）

```bash
cd rabbitmq-demo
docker-compose up -d
```

访问 RabbitMQ 管理界面：http://localhost:15672
- 用户名：admin
- 密码：admin123

#### 2. 启动后端 API

**Mock 模式（无需 RabbitMQ）：**
```bash
cd backend
pip install -r requirements.txt
APP_MODE=mock uvicorn app.main:app --reload
```

**Real 模式（需要 RabbitMQ）：**
```bash
cd backend
pip install -r requirements.txt
APP_MODE=real uvicorn app.main:app --reload
```

API 文档：http://localhost:8000/docs

#### 3. 打开前端页面

```bash
cd frontend
python -m http.server 8080
```

访问：http://localhost:8080

### 使用流程

1. **选择模式**
   - 点击右上角的模式切换按钮
   - Mock 模式：无需后端，适合快速演示
   - Real 模式：连接真实 RabbitMQ，完整体验

2. **发送消息**
   - 在左侧"生产者"区域输入队列名称
   - 输入消息内容
   - 点击"发送消息"按钮

3. **接收消息**
   - 右侧"消费者"区域会自动显示接收到的消息
   - 消息按时间倒序排列
   - 新消息会有动画效果

4. **查看统计**
   - 底部"队列监控"区域显示实时统计
   - 包括队列消息数、消费者数、已接收消息数

## API 接口说明

### 1. 发送消息

```http
POST /api/queues/{queue_name}/messages
Content-Type: application/json

{
  "body": "Hello, RabbitMQ!"
}
```

**响应：**
```json
{
  "status": "ok",
  "message": {
    "body": "Hello, RabbitMQ!",
    "timestamp": "2025-12-07T15:23:45.123456"
  }
}
```

### 2. 获取消息

```http
GET /api/queues/{queue_name}/messages?limit=10
```

**响应：**
```json
{
  "messages": [
    {
      "body": "Hello, RabbitMQ!",
      "timestamp": "2025-12-07T15:23:45.123456"
    }
  ]
}
```

### 3. 队列统计

```http
GET /api/queues/{queue_name}/stats
```

**响应：**
```json
{
  "message_count": 5,
  "consumer_count": 1
}
```

### 4. 健康检查

```http
GET /api/health
```

**响应：**
```json
{
  "status": "ok",
  "mode": "real",
  "rabbitmq": "connected"
}
```

## 常见问题

### Q1: Mock 模式和 Real 模式有什么区别？

**Mock 模式：**
- 前端使用内存队列模拟
- 无需启动后端和 RabbitMQ
- 适合快速演示和离线学习
- 刷新页面后数据会丢失

**Real 模式：**
- 连接真实的 RabbitMQ 服务
- 需要启动后端 API 和 RabbitMQ
- 完整体验消息队列的特性
- 数据持久化（取决于 RabbitMQ 配置）

### Q2: 如何切换模式？

**前端切换：**
点击页面右上角的"Mock 模式"或"真实连接"按钮

**后端切换：**
修改 `.env` 文件中的 `APP_MODE` 变量：
- `APP_MODE=mock` - Mock 模式
- `APP_MODE=real` - Real 模式

### Q3: 消息发送后看不到？

**检查清单：**
1. 确认 RabbitMQ 是否正常运行：`docker ps`
2. 确认后端 API 是否启动：访问 http://localhost:8000/health
3. 检查浏览器控制台是否有错误信息
4. 确认模式是否正确（Mock/Real）

### Q4: RabbitMQ 管理界面无法访问？

**解决方案：**
1. 确认 Docker 容器是否运行：`docker ps`
2. 确认端口映射是否正确：`docker-compose ps`
3. 重启 RabbitMQ 容器：`docker-compose restart rabbitmq`

### Q5: 如何查看 RabbitMQ 中的队列？

访问 RabbitMQ 管理界面：http://localhost:15672
- 用户名：admin
- 密码：admin123
- 点击"Queues"标签页查看所有队列

## 进阶学习

完成基础功能后，可以尝试以下进阶内容：

### 1. 消息持久化
- 修改代码实现消息持久化
- 重启 RabbitMQ 后消息不丢失

### 2. 消息确认机制
- 实现手动消息确认（manual ack）
- 处理消息失败时的重试逻辑

### 3. 死信队列（DLQ）
- 创建死信队列
- 处理无法消费的消息

### 4. 延迟队列
- 实现延迟消息发送
- 使用 TTL 和死信队列组合

### 5. 消息优先级
- 设置消息优先级
- 高优先级消息优先消费

### 6. 实时推送
- 使用 WebSocket 替代轮询
- 实现真正的实时消息推送

### 7. 多消费者
- 启动多个消费者进程
- 观察负载均衡效果

### 8. 交换机模式
- 实现 Fanout 交换机（广播）
- 实现 Direct 交换机（路由）
- 实现 Topic 交换机（主题）

## 相关资源

### 官方文档
- [RabbitMQ 官方文档](https://www.rabbitmq.com/documentation.html)
- [pika 文档](https://pika.readthedocs.io/)
- [FastAPI 文档](https://fastapi.tiangolo.com/)

### 推荐阅读
- [RabbitMQ 教程](https://www.rabbitmq.com/getstarted.html)
- [消息队列设计模式](https://www.enterpriseintegrationpatterns.com/)
- [微服务架构中的消息队列](https://microservices.io/patterns/data/event-driven-architecture.html)

### 视频教程
- [RabbitMQ 入门教程](https://www.youtube.com/results?search_query=rabbitmq+tutorial)
- [Python 消息队列实战](https://www.youtube.com/results?search_query=python+message+queue)

## 贡献指南

欢迎提交 Issue 和 Pull Request 来改进本项目！

## 许可证

本项目采用 MIT 许可证。
