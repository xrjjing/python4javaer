# 05 è®¤è¯ä¸æˆæƒï¼šOAuth2 + JWT + RBACï¼ˆFastAPI vs Spring Security è§†è§’ï¼‰

> é¢å‘å¯¹è±¡ï¼šä» Java / Spring Security è¿ç§»åˆ° Python / FastAPI çš„åŒå­¦ã€‚
> ç›®æ ‡ï¼šæŒæ¡ FastAPI ä¸­çš„ OAuth2 Password æµã€JWT ä»¤ç‰Œã€å¯†ç å“ˆå¸Œä¸åŸºäºä¾èµ–æ³¨å…¥çš„ RBACï¼Œç†è§£ä¸ Spring Security çš„å¯¹åº”å…³ç³»ã€‚

---

## 0. å¿«é€Ÿå¯¹ç…§ï¼šSpring Security vs FastAPI

| ç»´åº¦ | Spring Security | FastAPI |
| --- | --- | --- |
| è®¤è¯è¿‡æ»¤å™¨ | `UsernamePasswordAuthenticationFilter` | `OAuth2PasswordBearer` + ç™»å½•ç«¯ç‚¹ |
| JWT æ ¡éªŒ | `BearerTokenAuthenticationFilter` | è‡ªå®šä¹‰ `decode_token` ä¾èµ– |
| å¯†ç åŠ å¯† | `PasswordEncoder` (bcrypt) | `passlib.CryptContext` (bcrypt) |
| è§’è‰²æ ¡éªŒ | `@PreAuthorize("hasRole('ADMIN')")` | `Depends(require_role(["admin"]))` |
| æƒé™æ ¡éªŒ | `@PreAuthorize("hasAuthority('xxx')")` | `Depends(require_permission(["xxx"]))` |
| Token å­˜å‚¨ | `TokenStore` / Redis | é»‘åå• Set / Redis |
| é…ç½®æ–¹å¼ | `SecurityFilterChain` Bean | ä¾èµ–æ³¨å…¥é“¾ |

**è®°å¿†å¥**ï¼šFastAPI å®‰å…¨ = æ˜¾å¼ä¾èµ–æ³¨å…¥ï¼Œæ—  AOP é­”æ³•ï¼Œä»£ç å³é…ç½®ã€‚

---

## 1. ç¯å¢ƒå‡†å¤‡

### 1.1 å®‰è£…ä¾èµ–

```bash
pip install fastapi uvicorn
pip install "python-jose[cryptography]"  # JWT
pip install "passlib[bcrypt]"            # å¯†ç å“ˆå¸Œ
pip install pytest                       # æµ‹è¯•
```

### 1.2 é¡¹ç›®ç»“æ„

```
app/
  main.py           # FastAPI å…¥å£
  config.py         # é…ç½®ï¼ˆå¯†é’¥ã€è¿‡æœŸæ—¶é—´ï¼‰
  security.py       # å¯†ç å“ˆå¸Œã€JWT å·¥å…·
  dependencies.py   # è®¤è¯/æˆæƒä¾èµ–
  routers/
    auth.py         # ç™»å½•ã€åˆ·æ–°ã€ç™»å‡º
    protected.py    # å—ä¿æŠ¤ä¸šåŠ¡è·¯ç”±
```

---

## 2. å¯†ç å“ˆå¸Œï¼ˆpasslib + bcryptï¼‰

### 2.1 åŸºæœ¬ç”¨æ³•

```python
from passlib.context import CryptContext

# Java å¯¹æ¯”ï¼šnew BCryptPasswordEncoder()
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(raw: str) -> str:
    """å“ˆå¸Œå¯†ç ï¼Œå¯¹åº” Spring PasswordEncoder#encode"""
    return pwd_context.hash(raw)

def verify_password(raw: str, hashed: str) -> bool:
    """æ ¡éªŒå¯†ç ï¼Œå¯¹åº” Spring PasswordEncoder#matches"""
    return pwd_context.verify(raw, hashed)
```

### 2.2 ä½¿ç”¨ç¤ºä¾‹

```python
# æ³¨å†Œæ—¶å­˜å‚¨å“ˆå¸Œ
hashed = hash_password("user_password_123")

# ç™»å½•æ—¶æ ¡éªŒ
if verify_password("user_password_123", hashed):
    print("å¯†ç æ­£ç¡®")
```

### 2.3 å®‰å…¨æç¤º

| âŒ ä¸è¦ | âœ… åº”è¯¥ |
| --- | --- |
| MD5 / SHA1 | bcrypt / scrypt / argon2 |
| æ˜æ–‡å­˜å‚¨ | åªå­˜å“ˆå¸Œå€¼ |
| è‡ªå·±å®ç°åŠ ç› | ä½¿ç”¨ passlib è‡ªåŠ¨å¤„ç† |

---

## 3. OAuth2 Password Flow

### 3.1 æ¦‚å¿µ

OAuth2 Password Flow é€‚ç”¨äº**ç¬¬ä¸€æ–¹åº”ç”¨**ï¼ˆç”¨æˆ·ç›´æ¥è¾“å…¥ç”¨æˆ·åå¯†ç ï¼‰ï¼š

```
å®¢æˆ·ç«¯ â†’ POST /auth/login (username, password)
æœåŠ¡ç«¯ â†’ è¿”å› {access_token, refresh_token, token_type}
å®¢æˆ·ç«¯ â†’ åç»­è¯·æ±‚æºå¸¦ Authorization: Bearer <token>
```

### 3.2 FastAPI å®ç°

```python
from fastapi import FastAPI, Depends, HTTPException
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm

app = FastAPI()

# å£°æ˜ token è·å–ç«¯ç‚¹ï¼Œç±»ä¼¼ Spring Security çš„ tokenUrl
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/login")

@app.post("/auth/login")
def login(form: OAuth2PasswordRequestForm = Depends()):
    """
    OAuth2PasswordRequestForm è‡ªåŠ¨è§£æ form-data:
    - username
    - password
    å¯¹åº” Spring Security çš„ UsernamePasswordAuthenticationFilter
    """
    user = authenticate_user(form.username, form.password)
    if not user:
        raise HTTPException(status_code=400, detail="ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯")

    access_token = create_access_token(user)
    refresh_token = create_refresh_token(user)
    return {"access_token": access_token, "refresh_token": refresh_token, "token_type": "bearer"}
```

---

## 4. JWT ç”Ÿæˆä¸éªŒè¯

### 4.1 é…ç½®

```python
from datetime import datetime, timedelta, timezone

# ç”Ÿäº§ç¯å¢ƒè¯·ä½¿ç”¨ç¯å¢ƒå˜é‡
SECRET_KEY = "your-secret-key"
REFRESH_SECRET_KEY = "your-refresh-secret"
ALGORITHM = "HS256"
ACCESS_EXPIRE_MINUTES = 15
REFRESH_EXPIRE_DAYS = 7
```

### 4.2 ç”Ÿæˆ Token

```python
from jose import jwt

def create_access_token(user, expires_delta: timedelta = None) -> str:
    expire = datetime.now(timezone.utc) + (expires_delta or timedelta(minutes=ACCESS_EXPIRE_MINUTES))
    payload = {
        "sub": user.username,           # ä¸»ä½“ï¼ˆç”¨æˆ·æ ‡è¯†ï¼‰
        "role": user.roles,             # è§’è‰²åˆ—è¡¨
        "perms": user.permissions,      # æƒé™åˆ—è¡¨
        "exp": expire,                  # è¿‡æœŸæ—¶é—´
        "iat": datetime.now(timezone.utc),  # ç­¾å‘æ—¶é—´
        "jti": generate_jti(),          # å”¯ä¸€æ ‡è¯†ï¼ˆç”¨äºåŠé”€ï¼‰
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

def create_refresh_token(user) -> str:
    expire = datetime.now(timezone.utc) + timedelta(days=REFRESH_EXPIRE_DAYS)
    payload = {
        "sub": user.username,
        "type": "refresh",
        "exp": expire,
        "jti": generate_jti(),
    }
    return jwt.encode(payload, REFRESH_SECRET_KEY, algorithm=ALGORITHM)
```

### 4.3 éªŒè¯ Token

```python
from jose import jwt, JWTError
from fastapi import HTTPException, status

def decode_token(token: str, secret: str = SECRET_KEY) -> dict:
    try:
        payload = jwt.decode(token, secret, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="ä»¤ç‰Œæ— æ•ˆæˆ–å·²è¿‡æœŸ",
            headers={"WWW-Authenticate": "Bearer"},
        )
```

### 4.4 JWT Claims è¯´æ˜

| Claim | è¯´æ˜ | Java å¯¹æ¯” |
| --- | --- | --- |
| `sub` | Subjectï¼Œç”¨æˆ·æ ‡è¯† | `Authentication.getName()` |
| `exp` | Expirationï¼Œè¿‡æœŸæ—¶é—´æˆ³ | `Jwt.getExpiresAt()` |
| `iat` | Issued Atï¼Œç­¾å‘æ—¶é—´ | `Jwt.getIssuedAt()` |
| `jti` | JWT IDï¼Œå”¯ä¸€æ ‡è¯† | ç”¨äºé»‘åå•/åŠé”€ |
| `role` | è‡ªå®šä¹‰ï¼šè§’è‰²åˆ—è¡¨ | `GrantedAuthority` |
| `perms` | è‡ªå®šä¹‰ï¼šæƒé™åˆ—è¡¨ | `hasAuthority()` |

---

## 5. Access Token + Refresh Token æ¨¡å¼

### 5.1 è®¾è®¡åŸåˆ™

| Token | æœ‰æ•ˆæœŸ | ç”¨é€” | å­˜å‚¨ä½ç½® |
| --- | --- | --- | --- |
| Access Token | 5-15 åˆ†é’Ÿ | è®¿é—® API | å†…å­˜ / localStorage |
| Refresh Token | 7-30 å¤© | æ¢å–æ–° Access | HttpOnly Cookie / å®‰å…¨å­˜å‚¨ |

### 5.2 åˆ·æ–°æµç¨‹

```python
@app.post("/auth/refresh")
def refresh(refresh_token: str):
    # 1. éªŒè¯ refresh token
    payload = decode_token(refresh_token, REFRESH_SECRET_KEY)

    # 2. æ£€æŸ¥æ˜¯å¦åœ¨é»‘åå•
    if payload["jti"] in revoked_tokens:
        raise HTTPException(status_code=401, detail="åˆ·æ–°ä»¤ç‰Œå·²åŠé”€")

    # 3. åŠé”€æ—§ refreshï¼ˆæ—‹è½¬ç­–ç•¥ï¼‰
    revoked_tokens.add(payload["jti"])

    # 4. ç­¾å‘æ–° token å¯¹
    user = get_user_by_username(payload["sub"])
    return {
        "access_token": create_access_token(user),
        "refresh_token": create_refresh_token(user),
        "token_type": "bearer"
    }
```

### 5.3 Java å¯¹æ¯”

| Spring Security | FastAPI |
| --- | --- |
| `RefreshTokenService` | `/auth/refresh` ç«¯ç‚¹ |
| `TokenStore.removeAccessToken()` | `revoked_tokens.add(jti)` |
| è‡ªåŠ¨ç»­ç­¾ï¼ˆå¯é€‰ï¼‰ | æ˜¾å¼è°ƒç”¨åˆ·æ–°ç«¯ç‚¹ |

---

## 6. RBAC ä¾èµ–æ³¨å…¥

### 6.1 è·å–å½“å‰ç”¨æˆ·

```python
from fastapi import Depends
from pydantic import BaseModel
from typing import List

class User(BaseModel):
    username: str
    roles: List[str]
    permissions: List[str]

def get_current_user(token: str = Depends(oauth2_scheme)) -> User:
    """
    è§£æ token å¹¶è¿”å›å½“å‰ç”¨æˆ·
    å¯¹åº” Spring Security çš„ SecurityContextHolder.getContext().getAuthentication()
    """
    payload = decode_token(token)

    # é»‘åå•æ£€æŸ¥
    if payload["jti"] in revoked_tokens:
        raise HTTPException(status_code=401, detail="ä»¤ç‰Œå·²åŠé”€")

    return User(
        username=payload["sub"],
        roles=payload.get("role", []),
        permissions=payload.get("perms", [])
    )
```

### 6.2 è§’è‰²æ ¡éªŒä¾èµ–

```python
def require_role(allowed_roles: List[str]):
    """
    è§’è‰²æ ¡éªŒä¾èµ–å·¥å‚
    å¯¹åº” Spring @PreAuthorize("hasRole('ADMIN')")
    """
    def dependency(user: User = Depends(get_current_user)) -> User:
        if not set(allowed_roles).intersection(user.roles):
            raise HTTPException(status_code=403, detail="è§’è‰²æƒé™ä¸è¶³")
        return user
    return dependency

# ä½¿ç”¨ç¤ºä¾‹
@app.get("/admin/dashboard")
def admin_dashboard(user: User = Depends(require_role(["admin"]))):
    return {"message": f"æ¬¢è¿ç®¡ç†å‘˜ {user.username}"}
```

### 6.3 æƒé™æ ¡éªŒä¾èµ–

```python
def require_permission(required_perms: List[str]):
    """
    æƒé™æ ¡éªŒä¾èµ–å·¥å‚
    å¯¹åº” Spring @PreAuthorize("hasAuthority('user:write')")
    """
    def dependency(user: User = Depends(get_current_user)) -> User:
        if not set(required_perms).issubset(user.permissions):
            raise HTTPException(status_code=403, detail="æ“ä½œæƒé™ä¸è¶³")
        return user
    return dependency

# ä½¿ç”¨ç¤ºä¾‹
@app.delete("/users/{user_id}")
def delete_user(user_id: int, user: User = Depends(require_permission(["user:delete"]))):
    return {"message": f"ç”¨æˆ· {user_id} å·²åˆ é™¤"}
```

### 6.4 ä¾èµ–é“¾ç¤ºæ„

```
è¯·æ±‚ â†’ OAuth2PasswordBearer(æå– token)
     â†’ get_current_user(è§£æ + é»‘åå•æ£€æŸ¥)
     â†’ require_role / require_permission(RBAC æ ¡éªŒ)
     â†’ ä¸šåŠ¡é€»è¾‘
```

---

## 7. ä»¤ç‰ŒåŠé”€ä¸é»‘åå•

### 7.1 ç­–ç•¥å¯¹æ¯”

| ç­–ç•¥ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
| --- | --- | --- | --- |
| JTI é»‘åå• | ç²¾ç¡®åŠé”€å•ä¸ª token | éœ€è¦å­˜å‚¨ | ç™»å‡ºã€å¼‚å¸¸æ£€æµ‹ |
| Token Version | æ‰¹é‡å¤±æ•ˆç”¨æˆ·æ‰€æœ‰ token | éœ€è¦æŸ¥ DB | å¯†ç ä¿®æ”¹ã€è´¦æˆ·é”å®š |
| çŸ­æœ‰æ•ˆæœŸ | æ— éœ€å­˜å‚¨ | ç”¨æˆ·ä½“éªŒå·® | é«˜å®‰å…¨è¦æ±‚ |

### 7.2 JTI é»‘åå•å®ç°

```python
# ç”Ÿäº§ç¯å¢ƒä½¿ç”¨ Redis
revoked_tokens: set = set()

@app.post("/auth/logout")
def logout(token: str = Depends(oauth2_scheme)):
    payload = decode_token(token)
    revoked_tokens.add(payload["jti"])
    return {"message": "å·²ç™»å‡º"}
```

### 7.3 Token Version å®ç°

```python
# ç”¨æˆ·è¡¨å¢åŠ  token_version å­—æ®µ
class UserInDB:
    username: str
    password_hash: str
    token_version: int = 1  # æ¯æ¬¡å¯†ç ä¿®æ”¹ +1

def get_current_user(token: str = Depends(oauth2_scheme)) -> User:
    payload = decode_token(token)
    user = get_user_from_db(payload["sub"])

    # ç‰ˆæœ¬å·æ ¡éªŒ
    if payload.get("token_version") != user.token_version:
        raise HTTPException(status_code=401, detail="ä»¤ç‰Œå·²å¤±æ•ˆï¼Œè¯·é‡æ–°ç™»å½•")

    return user
```

---

## 8. å®Œæ•´ç¤ºä¾‹

```python
# main.py
from datetime import datetime, timedelta, timezone
from typing import List, Set
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import jwt, JWTError
from passlib.context import CryptContext
from pydantic import BaseModel
import uuid

# === é…ç½® ===
SECRET_KEY = "your-access-secret"
REFRESH_SECRET = "your-refresh-secret"
ALGORITHM = "HS256"
ACCESS_EXPIRE_MIN = 15
REFRESH_EXPIRE_DAYS = 7

# === å·¥å…· ===
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/login")
revoked_tokens: Set[str] = set()

# === æ¨¡æ‹Ÿç”¨æˆ·æ•°æ® ===
fake_users = {
    "admin": {
        "password_hash": pwd_context.hash("admin123"),
        "roles": ["admin"],
        "perms": ["user:read", "user:write", "user:delete"],
    },
    "user": {
        "password_hash": pwd_context.hash("user123"),
        "roles": ["user"],
        "perms": ["user:read"],
    },
}

# === Pydantic æ¨¡å‹ ===
class User(BaseModel):
    username: str
    roles: List[str]
    perms: List[str]

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"

# === å·¥å…·å‡½æ•° ===
def create_token(data: dict, secret: str, expires: timedelta) -> str:
    payload = data.copy()
    payload["exp"] = datetime.now(timezone.utc) + expires
    payload["iat"] = datetime.now(timezone.utc)
    payload["jti"] = str(uuid.uuid4())
    return jwt.encode(payload, secret, algorithm=ALGORITHM)

def decode_token(token: str, secret: str) -> dict:
    try:
        return jwt.decode(token, secret, algorithms=[ALGORITHM])
    except JWTError:
        raise HTTPException(status_code=401, detail="ä»¤ç‰Œæ— æ•ˆæˆ–è¿‡æœŸ")

# === ä¾èµ– ===
def get_current_user(token: str = Depends(oauth2_scheme)) -> User:
    payload = decode_token(token, SECRET_KEY)
    if payload["jti"] in revoked_tokens:
        raise HTTPException(status_code=401, detail="ä»¤ç‰Œå·²åŠé”€")
    return User(username=payload["sub"], roles=payload["role"], perms=payload["perms"])

def require_role(roles: List[str]):
    def dep(user: User = Depends(get_current_user)):
        if not set(roles) & set(user.roles):
            raise HTTPException(status_code=403, detail="è§’è‰²ä¸è¶³")
        return user
    return dep

def require_permission(perms: List[str]):
    def dep(user: User = Depends(get_current_user)):
        if not set(perms).issubset(user.perms):
            raise HTTPException(status_code=403, detail="æƒé™ä¸è¶³")
        return user
    return dep

# === FastAPI åº”ç”¨ ===
app = FastAPI(title="Auth Demo")

@app.post("/auth/login", response_model=TokenResponse)
def login(form: OAuth2PasswordRequestForm = Depends()):
    user_data = fake_users.get(form.username)
    if not user_data or not pwd_context.verify(form.password, user_data["password_hash"]):
        raise HTTPException(status_code=400, detail="ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯")

    access = create_token(
        {"sub": form.username, "role": user_data["roles"], "perms": user_data["perms"]},
        SECRET_KEY, timedelta(minutes=ACCESS_EXPIRE_MIN)
    )
    refresh = create_token(
        {"sub": form.username, "type": "refresh"},
        REFRESH_SECRET, timedelta(days=REFRESH_EXPIRE_DAYS)
    )
    return TokenResponse(access_token=access, refresh_token=refresh)

@app.post("/auth/refresh", response_model=TokenResponse)
def refresh(refresh_token: str):
    """åˆ·æ–°ä»¤ç‰Œç«¯ç‚¹ï¼šéªŒè¯ refresh token å¹¶ç­¾å‘æ–° token å¯¹"""
    payload = decode_token(refresh_token, REFRESH_SECRET)
    if payload.get("type") != "refresh":
        raise HTTPException(status_code=401, detail="æ— æ•ˆçš„åˆ·æ–°ä»¤ç‰Œ")
    if payload["jti"] in revoked_tokens:
        raise HTTPException(status_code=401, detail="åˆ·æ–°ä»¤ç‰Œå·²åŠé”€")
    # åŠé”€æ—§ refreshï¼ˆæ—‹è½¬ç­–ç•¥ï¼‰
    revoked_tokens.add(payload["jti"])
    # ç­¾å‘æ–° token å¯¹
    user_data = fake_users.get(payload["sub"])
    access = create_token(
        {"sub": payload["sub"], "role": user_data["roles"], "perms": user_data["perms"]},
        SECRET_KEY, timedelta(minutes=ACCESS_EXPIRE_MIN)
    )
    refresh_new = create_token(
        {"sub": payload["sub"], "type": "refresh"},
        REFRESH_SECRET, timedelta(days=REFRESH_EXPIRE_DAYS)
    )
    return TokenResponse(access_token=access, refresh_token=refresh_new)

@app.post("/auth/logout")
def logout(token: str = Depends(oauth2_scheme)):
    payload = decode_token(token, SECRET_KEY)
    revoked_tokens.add(payload["jti"])
    return {"message": "å·²ç™»å‡º"}

@app.get("/me")
def me(user: User = Depends(get_current_user)):
    return user

@app.get("/admin/dashboard")
def admin_dashboard(user: User = Depends(require_role(["admin"]))):
    return {"message": f"æ¬¢è¿ç®¡ç†å‘˜ {user.username}"}

@app.delete("/users/{user_id}")
def delete_user(user_id: int, user: User = Depends(require_permission(["user:delete"]))):
    return {"message": f"ç”¨æˆ· {user_id} å·²è¢« {user.username} åˆ é™¤"}
```

> âš ï¸ **ç”Ÿäº§æ³¨æ„**ï¼šç¤ºä¾‹ä¸­å¯†é’¥ç¡¬ç¼–ç ä»…ç”¨äºæ¼”ç¤ºï¼Œç”Ÿäº§ç¯å¢ƒå¿…é¡»ä½¿ç”¨ç¯å¢ƒå˜é‡æˆ–å¯†é’¥ç®¡ç†æœåŠ¡ï¼ˆå¦‚ AWS Secrets Managerã€HashiCorp Vaultï¼‰ã€‚

---

## 9. âš ï¸ å¸¸è§é™·é˜±

### 9.1 Java å¼€å‘è€…å¸¸è¸©å‘

1. **å¿˜è®°è®¾ç½® exp**
   - é—®é¢˜ï¼šToken æ°¸ä¸è¿‡æœŸ
   - è§£å†³ï¼šå§‹ç»ˆåœ¨ payload ä¸­è®¾ç½® `exp`

2. **æ··ç”¨ Access / Refresh Token**
   - é—®é¢˜ï¼šç”¨ Refresh Token è®¿é—® API
   - è§£å†³ï¼šä½¿ç”¨ä¸åŒå¯†é’¥ï¼Œæ ¡éªŒ `type` å­—æ®µ

3. **é»‘åå•åªåœ¨å®¢æˆ·ç«¯åˆ é™¤**
   - é—®é¢˜ï¼šæ—§ Token ä»ç„¶æœ‰æ•ˆ
   - è§£å†³ï¼šæœåŠ¡ç«¯ç»´æŠ¤ JTI é»‘åå•

4. **å¼‚æ­¥è·¯ç”±ç”¨åŒæ­¥ DB æŸ¥è¯¢**
   - é—®é¢˜ï¼šé˜»å¡äº‹ä»¶å¾ªç¯
   - è§£å†³ï¼šä½¿ç”¨å¼‚æ­¥ DB é©±åŠ¨æˆ–çº¿ç¨‹æ± 

5. **å¯†é’¥ç¡¬ç¼–ç **
   - é—®é¢˜ï¼šå®‰å…¨é£é™©
   - è§£å†³ï¼šä½¿ç”¨ç¯å¢ƒå˜é‡æˆ–å¯†é’¥ç®¡ç†æœåŠ¡

### 9.2 å®‰å…¨æ¸…å•

- [ ] å¯†ç ä½¿ç”¨ bcrypt å“ˆå¸Œ
- [ ] JWT å¯†é’¥è¶³å¤Ÿå¤æ‚ï¼ˆ32+ å­—ç¬¦ï¼‰
- [ ] Access Token æœ‰æ•ˆæœŸ â‰¤ 15 åˆ†é’Ÿ
- [ ] Refresh Token ä½¿ç”¨ç‹¬ç«‹å¯†é’¥
- [ ] å®ç° Token åŠé”€æœºåˆ¶
- [ ] HTTPS ä¼ è¾“
- [ ] æ•æ„Ÿæ“ä½œäºŒæ¬¡éªŒè¯

---

## 10. ğŸ’¡ æœ€ä½³å®è·µ

1. **åˆ†ç¦»å…³æ³¨ç‚¹**ï¼šè®¤è¯é€»è¾‘æ”¾ `security.py`ï¼Œä¸šåŠ¡é€»è¾‘æ”¾è·¯ç”±
2. **ä¾èµ–é“¾æ¸…æ™°**ï¼š`oauth2_scheme` â†’ `get_current_user` â†’ `require_role`
3. **é…ç½®å¤–ç½®**ï¼šå¯†é’¥ã€è¿‡æœŸæ—¶é—´èµ°ç¯å¢ƒå˜é‡
4. **é»‘åå•æŒä¹…åŒ–**ï¼šç”Ÿäº§ç¯å¢ƒç”¨ Redisï¼Œè®¾ç½®ä¸ Token ç›¸åŒçš„ TTL
5. **æ—¥å¿—å®¡è®¡**ï¼šè®°å½•ç™»å½•ã€ç™»å‡ºã€æƒé™æ‹’ç»äº‹ä»¶
6. **å‚è€ƒç°æœ‰å®ç°**ï¼šæœ¬ä»“åº“ `rbac_auth_service` æœ‰å®Œæ•´ RBAC ç¤ºä¾‹

---

## 11. ç»ƒä¹ 

### ç»ƒä¹  1ï¼šç™»å½•ä¸ Token å‘æ”¾

å®ç° `/auth/login` ç«¯ç‚¹ï¼š
- æ¥æ”¶ username/password
- è¿”å› access_token + refresh_token
- ç¼–å†™æµ‹è¯•è¦†ç›–æ­£ç¡®/é”™è¯¯å¯†ç åœºæ™¯

### ç»ƒä¹  2ï¼šRBAC è·¯ç”±ä¿æŠ¤

å®ç°å—ä¿æŠ¤è·¯ç”±ï¼š
- `/admin/users` ä»… admin è§’è‰²å¯è®¿é—®
- `/docs` éœ€è¦ `doc:read` æƒé™
- æµ‹è¯• 200/403 åœºæ™¯

### ç»ƒä¹  3ï¼šToken åˆ·æ–°

å®ç° `/auth/refresh`ï¼š
- éªŒè¯ Refresh Token
- åŠé”€æ—§ Refreshï¼ˆæ—‹è½¬ç­–ç•¥ï¼‰
- ç­¾å‘æ–° Token å¯¹

### ç»ƒä¹  4ï¼šç™»å‡ºä¸é»‘åå•

å®ç° `/auth/logout`ï¼š
- å°†å½“å‰ Token JTI åŠ å…¥é»‘åå•
- éªŒè¯ç™»å‡ºåæ— æ³•è®¿é—® API

---

## 12. Java vs Python å°è´´å£«

| åœºæ™¯ | Spring Security | FastAPI |
| --- | --- | --- |
| é…ç½®æ–¹å¼ | `@EnableWebSecurity` + Bean | ä¾èµ–æ³¨å…¥å‡½æ•° |
| è·å–å½“å‰ç”¨æˆ· | `SecurityContextHolder` | `Depends(get_current_user)` |
| è§’è‰²å‰ç¼€ | `ROLE_ADMIN` | è‡ªå®šä¹‰ï¼Œæ— å‰ç¼€è¦æ±‚ |
| æ–¹æ³•çº§å®‰å…¨ | `@PreAuthorize` | `Depends(require_xxx)` |
| Filter é“¾ | `SecurityFilterChain` | ä¾èµ–é“¾ / ä¸­é—´ä»¶ |
| æ— çŠ¶æ€é…ç½® | `.sessionManagement().stateless()` | é»˜è®¤æ— çŠ¶æ€ |

---

## 13. å°ç»“

- FastAPI å®‰å…¨åŸºäºä¾èµ–æ³¨å…¥ï¼Œæ—  AOP é­”æ³•ï¼Œä»£ç å³é…ç½®
- `OAuth2PasswordBearer` + è‡ªå®šä¹‰ decode å®ç° JWT è®¤è¯
- `passlib` + bcrypt å¤„ç†å¯†ç å“ˆå¸Œ
- Access + Refresh Token æ¨¡å¼å…¼é¡¾å®‰å…¨ä¸ä½“éªŒ
- RBAC é€šè¿‡ä¾èµ–å·¥å‚ `require_role`/`require_permission` å®ç°
- Token åŠé”€å¯ç”¨ JTI é»‘åå•æˆ– Version å·
- å‚è€ƒ `rbac_auth_service` äº†è§£ç”Ÿäº§çº§å®ç°
