# 06 中间件与跨切面（FastAPI vs Spring 视角）

> 面向对象：从 Java / Spring 迁移到 Python / FastAPI 的同学。
> 目标：掌握 FastAPI 中间件机制、CORS 配置、日志追踪、全局异常处理与限流，理解与 Spring Filter/Interceptor/@ControllerAdvice 的映射。

---

## 0. 快速对照：Spring vs FastAPI

| 维度 | Spring | FastAPI |
| --- | --- | --- |
| 请求过滤 | `Filter` | `@app.middleware("http")` |
| 前后置处理 | `Interceptor` | Middleware / 带 `yield` 的 `Depends`（路由级） |
| 全局异常 | `@ControllerAdvice` + `@ExceptionHandler` | `@app.exception_handler(...)` |
| 日志上下文 | MDC (Mapped Diagnostic Context) | `contextvars` |
| CORS 配置 | `@CrossOrigin` / `WebMvcConfigurer` | `CORSMiddleware` |
| 限流 | Bucket4j / Resilience4j | slowapi / 自定义中间件 |

**记忆句**：FastAPI 中间件 = ASGI 调用链包装，类似 Spring Filter，但更轻量。

---

## 1. 中间件概述

### 1.1 生命周期

```
请求 → Middleware 1 (before) → Middleware 2 (before) → Route Handler
                                                              ↓
响应 ← Middleware 1 (after)  ← Middleware 2 (after)  ← Response
```

### 1.2 基本结构

```python
from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")
async def my_middleware(request: Request, call_next):
    # 前置处理
    print(f"Before: {request.url.path}")

    response = await call_next(request)  # 调用下游

    # 后置处理
    print(f"After: {response.status_code}")
    return response
```

### 1.3 Java 对比

```java
// Spring Filter
@Component
public class MyFilter implements Filter {
    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) {
        // 前置处理
        chain.doFilter(req, res);  // 调用下游
        // 后置处理
    }
}
```

---

## 2. CORS 配置

### 2.1 基本配置

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # 允许的前端域名
    allow_credentials=True,                    # 允许携带 Cookie
    allow_methods=["*"],                       # 允许所有 HTTP 方法
    allow_headers=["*"],                       # 允许所有请求头
)
```

### 2.2 参数说明

| 参数 | 说明 | 注意事项 |
| --- | --- | --- |
| `allow_origins` | 允许的源列表 | 不能与 `credentials=True` 同时用 `["*"]` |
| `allow_credentials` | 是否允许携带凭证 | 设为 True 时 origins 必须明确列出 |
| `allow_methods` | 允许的 HTTP 方法 | `["*"]` 表示所有 |
| `allow_headers` | 允许的请求头 | `["*"]` 表示所有 |
| `max_age` | 预检请求缓存时间（秒） | 默认 600 |

### 2.3 常见错误

```python
# ❌ 错误：credentials=True 时不能用 *
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],      # 浏览器会拒绝
    allow_credentials=True,
)

# ✅ 正确：明确列出允许的域名
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "https://example.com"],
    allow_credentials=True,
)
```

---

## 3. 请求日志中间件

### 3.1 基本实现

```python
import time
import logging
from fastapi import Request

logger = logging.getLogger(__name__)

@app.middleware("http")
async def logging_middleware(request: Request, call_next):
    start = time.perf_counter()

    response = await call_next(request)

    duration_ms = (time.perf_counter() - start) * 1000
    logger.info(
        "method=%s path=%s status=%s duration=%.2fms",
        request.method,
        request.url.path,
        response.status_code,
        duration_ms,
    )

    # 可选：响应头添加耗时
    response.headers["X-Response-Time-ms"] = f"{duration_ms:.2f}"
    return response
```

### 3.2 敏感字段脱敏

```python
from typing import Any

def mask_sensitive(data: Any, sensitive_keys: set = None) -> Any:
    """递归脱敏敏感字段，支持嵌套结构"""
    if sensitive_keys is None:
        sensitive_keys = {"password", "token", "secret", "authorization", "api_key"}

    if isinstance(data, dict):
        return {
            k: "***" if k.lower() in sensitive_keys else mask_sensitive(v, sensitive_keys)
            for k, v in data.items()
        }
    elif isinstance(data, list):
        return [mask_sensitive(item, sensitive_keys) for item in data]
    return data
```

---

## 4. Request ID / Trace ID

### 4.1 使用 contextvars（类似 Java MDC）

```python
import uuid
import contextvars
from fastapi import Request

# 创建上下文变量
request_id_ctx: contextvars.ContextVar[str] = contextvars.ContextVar("request_id", default="-")

@app.middleware("http")
async def request_id_middleware(request: Request, call_next):
    # 从请求头获取或生成新的 Request ID
    req_id = request.headers.get("X-Request-ID", str(uuid.uuid4()))

    # 存入上下文
    token = request_id_ctx.set(req_id)
    response = None
    try:
        response = await call_next(request)
    except Exception:
        # 异常时也要确保响应头包含 Request ID
        raise
    finally:
        request_id_ctx.reset(token)
        # 无论成功还是异常，确保响应头包含 Request ID
        if response is not None:
            response.headers["X-Request-ID"] = req_id

    return response
```

### 4.2 在日志中使用

```python
import logging

class RequestIdFilter(logging.Filter):
    """为日志记录添加 request_id 字段"""
    def filter(self, record):
        record.request_id = request_id_ctx.get()
        return True

# 配置日志格式（添加到根 logger 避免 KeyError）
root_logger = logging.getLogger()
root_logger.addFilter(RequestIdFilter())
logging.basicConfig(
    format="%(asctime)s [%(request_id)s] %(levelname)s %(message)s",
    level=logging.INFO,
)

logger = logging.getLogger(__name__)
```

### 4.3 Java MDC 对比

```java
// Java MDC
MDC.put("requestId", uuid);
try {
    // 处理请求
} finally {
    MDC.remove("requestId");
}
```

---

## 5. 全局异常处理

### 5.1 自定义业务异常

```python
from fastapi import status

class BusinessError(Exception):
    """业务异常基类"""
    def __init__(self, code: str, message: str, http_status: int = status.HTTP_400_BAD_REQUEST):
        self.code = code
        self.message = message
        self.http_status = http_status
```

### 5.2 注册异常处理器

```python
from fastapi import Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError

@app.exception_handler(BusinessError)
async def business_error_handler(request: Request, exc: BusinessError):
    """处理业务异常，类似 Spring @ExceptionHandler"""
    return JSONResponse(
        status_code=exc.http_status,
        content={
            "code": exc.code,
            "message": exc.message,
            "request_id": request_id_ctx.get(),
        },
    )

@app.exception_handler(RequestValidationError)
async def validation_error_handler(request: Request, exc: RequestValidationError):
    """覆盖默认的 422 响应格式，保持与 BusinessError 一致"""
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "code": "VALIDATION_ERROR",
            "message": "参数校验失败",
            "errors": exc.errors(),
            "request_id": request_id_ctx.get(),  # 确保错误响应也包含 request_id
        },
    )
```

### 5.3 使用示例

```python
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    user = find_user(user_id)
    if not user:
        raise BusinessError("USER_NOT_FOUND", "用户不存在", http_status=404)
    return user
```

### 5.4 Java 对比

```java
// Spring @ControllerAdvice
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessError(BusinessException e) {
        return ResponseEntity.status(e.getStatus())
            .body(new ErrorResponse(e.getCode(), e.getMessage()));
    }
}
```

---

## 6. 限流

### 6.1 简易内存限流（演示用）

```python
from collections import defaultdict, deque
from datetime import datetime
from fastapi import Request
from fastapi.responses import JSONResponse

WINDOW_SECONDS = 60
MAX_REQUESTS = 100
CLEANUP_THRESHOLD = 10000  # IP 数阈值，超过则清理
request_history: defaultdict[str, deque] = defaultdict(deque)

def cleanup_expired_ips():
    """清理无活动记录的 IP，防止内存无界增长"""
    now = datetime.utcnow().timestamp()
    window_start = now - WINDOW_SECONDS
    expired_ips = [ip for ip, hist in request_history.items() if not hist or hist[-1] < window_start]
    for ip in expired_ips:
        del request_history[ip]

def is_rate_limited(client_ip: str) -> bool:
    now = datetime.utcnow().timestamp()
    window_start = now - WINDOW_SECONDS
    history = request_history[client_ip]

    # 清理该 IP 的过期记录
    while history and history[0] < window_start:
        history.popleft()

    # 定期清理全局过期 IP
    if len(request_history) > CLEANUP_THRESHOLD:
        cleanup_expired_ips()

    if len(history) >= MAX_REQUESTS:
        return True

    history.append(now)
    return False

@app.middleware("http")
async def rate_limit_middleware(request: Request, call_next):
    client_ip = request.client.host if request.client else "unknown"

    if is_rate_limited(client_ip):
        return JSONResponse(
            status_code=429,
            content={"detail": "Too Many Requests"},
        )

    return await call_next(request)
```

### 6.2 使用 slowapi（生产推荐）

```python
from slowapi import Limiter
from slowapi.util import get_remote_address
from slowapi.middleware import SlowAPIMiddleware

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_middleware(SlowAPIMiddleware)

@app.get("/api/heavy")
@limiter.limit("5/minute")
async def heavy_operation(request: Request):
    return {"result": "done"}
```

### 6.3 生产注意事项

| 单实例 | 多实例 |
| --- | --- |
| 内存计数即可 | 需要 Redis 共享存储 |
| 简单快速 | 需要原子操作（INCR + EXPIRE） |

---

## 7. 中间件 vs 依赖

### 7.1 选择指南

| 场景 | 推荐方式 | 原因 |
| --- | --- | --- |
| 日志/追踪 | 中间件 | 每请求必经，与路由无关 |
| CORS | 中间件 | 框架级配置 |
| 限流 | 中间件 | 无需路由参数 |
| 认证/鉴权 | 依赖 | 需要访问路由参数和用户上下文 |
| 数据库会话 | 依赖 | 请求级生命周期管理 |
| 权限校验 | 依赖 | 需要当前用户信息 |

### 7.2 Java 对比

| FastAPI | Spring | 适用场景 |
| --- | --- | --- |
| Middleware | Filter | 框架级横切（CORS、日志） |
| Depends | Interceptor / AOP | 业务级横切（认证、审计） |

---

## 8. 完整示例

```python
# main.py
import time
import uuid
import logging
import contextvars
from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# === 配置 ===
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

request_id_ctx: contextvars.ContextVar[str] = contextvars.ContextVar("request_id", default="-")

# === 异常 ===
class BusinessError(Exception):
    def __init__(self, code: str, message: str, http_status: int = 400):
        self.code = code
        self.message = message
        self.http_status = http_status

# === 应用 ===
app = FastAPI(title="Middleware Demo")

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Request ID
@app.middleware("http")
async def request_id_middleware(request: Request, call_next):
    req_id = request.headers.get("X-Request-ID", str(uuid.uuid4()))
    token = request_id_ctx.set(req_id)
    response = None
    try:
        response = await call_next(request)
    finally:
        request_id_ctx.reset(token)
        if response is not None:
            response.headers["X-Request-ID"] = req_id
    return response

# 日志 + 计时
@app.middleware("http")
async def logging_middleware(request: Request, call_next):
    start = time.perf_counter()
    response = await call_next(request)
    duration = (time.perf_counter() - start) * 1000
    logger.info(f"[{request_id_ctx.get()}] {request.method} {request.url.path} {response.status_code} {duration:.2f}ms")
    response.headers["X-Response-Time-ms"] = f"{duration:.2f}"
    return response

# 异常处理
@app.exception_handler(BusinessError)
async def business_error_handler(request: Request, exc: BusinessError):
    return JSONResponse(
        status_code=exc.http_status,
        content={"code": exc.code, "message": exc.message, "request_id": request_id_ctx.get()},
    )

@app.exception_handler(RequestValidationError)
async def validation_error_handler(request: Request, exc: RequestValidationError):
    return JSONResponse(
        status_code=422,
        content={"code": "VALIDATION_ERROR", "message": "参数校验失败", "errors": exc.errors(), "request_id": request_id_ctx.get()},
    )

# === 路由 ===
class EchoRequest(BaseModel):
    message: str

@app.get("/health")
async def health():
    return {"status": "ok"}

@app.post("/echo")
async def echo(payload: EchoRequest):
    return {"echo": payload.message, "request_id": request_id_ctx.get()}

@app.get("/error")
async def trigger_error():
    raise BusinessError("DEMO_ERROR", "这是一个演示错误", http_status=400)
```

---

## 9. ⚠️ 常见陷阱

1. **中间件内阻塞 I/O**
   - 问题：同步数据库/HTTP 调用阻塞事件循环
   - 解决：使用异步库或 `run_in_executor`

2. **CORS 配置错误**
   - 问题：`allow_origins=["*"]` + `allow_credentials=True`
   - 解决：明确列出允许的域名

3. **忘记传播 Request ID**
   - 问题：前后端无法关联日志
   - 解决：响应头必须返回 `X-Request-ID`

4. **异常处理返回非 JSON**
   - 问题：客户端解析失败
   - 解决：始终返回 `JSONResponse`

5. **单实例限流**
   - 问题：多实例部署失效
   - 解决：使用 Redis 共享存储

---

## 10. 练习

### 练习 1：Request ID 中间件
实现 Request ID 生成/透传：
- 从 `X-Request-ID` 获取或生成
- 存入 `contextvars`
- 返回响应头
- 测试验证

### 练习 2：全局异常处理
实现统一异常格式：
- 自定义 `BusinessError`
- 覆盖 `RequestValidationError`
- 测试 400/422/404 场景

### 练习 3：限流中间件
实现简易限流：
- 滑动窗口算法
- 返回 429 状态码
- 测试超限场景

### 练习 4：CORS 验证
配置 CORS：
- 允许特定域名
- 编写预检请求测试
- 验证响应头

---

## 11. Java vs Python 小贴士

| 场景 | Spring | FastAPI |
| --- | --- | --- |
| 请求过滤链 | FilterChain | ASGI middleware chain |
| 日志上下文 | MDC.put/get | contextvars |
| 异常映射 | @ResponseStatus | HTTPException / BusinessError |
| AOP 切面 | @Aspect | 中间件 + 依赖组合 |
| 限流注解 | @RateLimiter | @limiter.limit() |

---

## 12. 小结

- 中间件适合框架级横切：日志、追踪、CORS、限流
- 依赖适合业务级横切：认证、授权、数据库会话
- `contextvars` 是 Python 版 MDC，用于请求上下文传播
- `@app.exception_handler` 实现全局异常处理
- CORS 配置需注意 credentials 与 origins 的组合限制
- 生产限流需要 Redis 等共享存储
