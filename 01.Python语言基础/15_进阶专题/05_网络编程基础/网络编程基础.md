# 05_网络编程基础

> 本专题在你已经掌握文件操作、异常处理以及异步编程入门的基础上，系统补齐「网络编程」这条线，为后续更复杂的服务端开发和系统对接打下基础。

本节会围绕三个核心问题展开：

- 什么是网络编程，和日常开发有什么关系？
- 如何用标准库和 requests 完成常见的网络任务？
- 如何把这些能力应用到本仓库的实战项目中？

配套示例代码见：

- `01.Python语言基础/15_进阶专题/05_网络编程基础/demo_network_programming.py`

---

## 1. 网络编程的几个核心概念

在正式看代码之前，先用开发者视角快速把握几个关键概念：

- 进程之间如何「说话」：
  - 同一台机器：可以用管道、共享内存、本地 socket 等方式通信；
  - 不同机器：通常通过 TCP/UDP 协议在网络上通信。
- IP + 端口：
  - IP 表示「哪台机器」；
  - 端口表示「这台机器上的哪个应用」。
- 协议：
  - TCP：面向连接、可靠传输（适合大多数业务场景）；
  - UDP：无连接、尽力而为（适合对实时性要求更高的场景，如简单监控上报）。
- HTTP：
  - 建立在 TCP 之上的「应用层协议」，是 Web / API 世界的通用语言。

在本专题中，我们重点通过三个层次来理解网络编程：

1. HTTP 客户端：用 `requests` 调用 Web API；
2. socket 基础：用标准库写最小的 TCP 服务端与客户端；
3. 简单 HTTP 服务：用 `http.server` 快速暴露一个本地 HTTP 静态服务。

---

## 2. 用 requests 调用 Web API（HTTP 客户端）

在真实项目中，最常见的网络编程场景往往不是「自己写协议」，而是：

- 调用内部 Java 服务的 HTTP API；
- 调用第三方平台的 REST API；
- 从某个站点抓取公开数据（合法合规前提下）。

在本仓库中，你已经在以下实战项目中接触过类似场景：

- `03.项目实战/05_简单爬虫_新闻标题抓取`：使用 `requests` + `BeautifulSoup` 抓取新闻标题；
{- `03.项目实战/08_系统对接_调用Java服务API`：使用 `requests` 封装 Java 服务客户端，再通过 FastAPI 暴露网关接口。-}

在 `demo_network_programming.py` 中，你可以看到一个更通用的 HTTP 客户端封装示例：

```python
def fetch_json(url: str, timeout: float = 5.0) -> dict | list | None:
    """发送 GET 请求并尝试解析 JSON 响应。"""
    try:
        resp = requests.get(url, timeout=timeout)
        resp.raise_for_status()  # 非 2xx 会抛出异常
        return resp.json()
    except requests.RequestException as exc:
        print(f"请求失败：{exc}")
        return None
    except ValueError:
        print("响应体不是合法 JSON")
        return None
```

实践建议：

- 尝试调用一个公开的 JSON API（如公共天气接口、Github API 等），观察：
  - 如何设置超时时间；
  - 如何处理网络错误（超时、连接失败、HTTP 4xx / 5xx）。
- 对比项目 `client_java_service.py` 中的封装方式，思考在实际项目中应该在哪一层做错误处理和日志记录。

---

## 3. 用 socket 写一个最小的 TCP 回声服务

HTTP 是建立在 TCP 之上的「更高一层」协议，有时候理解底层的 TCP 有助于你更好地理解网络行为（例如连接断开、粘包、重传等问题）。

在 `demo_network_programming.py` 中，提供了一个非常小的 TCP 回声服务器与客户端示例：

- 服务器负责监听本地端口，接收客户端发来的数据，然后原样返回；
- 客户端连接到服务器，发送一条消息，并读取返回结果。

示例（伪代码形式）：

```python
def run_simple_tcp_server(host: str = "127.0.0.1", port: int = 9000) -> None:
    """简单的 TCP 回声服务器，仅用于本地实验。"""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
        server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_sock.bind((host, port))
        server_sock.listen(1)
        print(f"服务器已启动，监听 {host}:{port} ...")

        while True:
            conn, addr = server_sock.accept()
            with conn:
                print(f"收到来自 {addr} 的连接")
                while True:
                    data = conn.recv(1024)
                    if not data:
                        break
                    conn.sendall(data)
```

配套的客户端大致如下：

```python
def tcp_echo_client(message: str, host: str = "127.0.0.1", port: int = 9000) -> str:
    """连接到本地回声服务器，发送一条消息并返回响应内容。"""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.connect((host, port))
        sock.sendall(message.encode("utf-8"))
        data = sock.recv(1024)
        return data.decode("utf-8")
```

练习方法：

1. 打开一个终端，运行 `run_simple_tcp_server()`（可以在 Python REPL 中调用，或在 main 函数中调用并运行脚本）；
2. 打开另一个终端，运行调用 `tcp_echo_client("hello")` 的脚本；
3. 观察：
   - 服务器端打印的连接信息；
   - 客户端收到的回显内容。

通过这个示例，你可以直观感受到：

- TCP 连接的建立和关闭大致流程；
- 一次简单的「请求-响应」在底层如何通过 `sendall` / `recv` 实现。

---

## 4. 用 http.server 快速暴露本地 HTTP 静态服务

在开发阶段，你经常会需要「临时把某个目录暴露成 HTTP 静态服务器」，例如：

- 临时分享某个目录里的文件；
- 本地调试前端页面；
- 验证浏览器访问某个静态资源是否正常。

标准库中的 `http.server` 模块可以非常方便地完成这件事。在 `demo_network_programming.py` 中提供了一个简单封装：

```python
def run_simple_http_server(
    directory: str = ".",
    host: str = "127.0.0.1",
    port: int = 8000,
) -> None:
    """在指定目录下启动一个简单的 HTTP 静态文件服务器。"""
    path = Path(directory).resolve()
    os.chdir(path)
    server_address = (host, port)
    httpd = HTTPServer(server_address, SimpleHTTPRequestHandler)
    print(f"Serving {path} on http://{host}:{port}")

    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("收到中断信号，准备关闭服务器...")
    finally:
        httpd.server_close()
```

使用方式：

1. 在某个目录下新建几个测试文件（HTML / 文本 / 图片均可）；
2. 在 Python 交互环境中调用：

   ```python
   from demo_network_programming import run_simple_http_server
   run_simple_http_server(directory=".", port=8000)
   ```

3. 打开浏览器访问 `http://127.0.0.1:8000`，即可浏览该目录内容。

---

## 5. 和本仓库其他部分的串联

学习本专题时，建议把它和以下内容结合起来理解：

- 语言基础：
  - `08_异常与文件基础`：异常捕获、文件读写；
  - `14_开发技巧_写法优化` 中的 `with`、`pathlib`、`logging` 等。
- 进阶专题：
  - `07_异步编程入门`：理解同步 socket 和异步网络编程之间的区别；
  - 未来可在「06_多线程与多进程」中进一步练习高并发场景。
- 项目实战：
  - `05_简单爬虫_新闻标题抓取`：把本专题的 HTTP 客户端封装思想应用到爬虫中；
  - `08_系统对接_调用Java服务API`：对比 demo 中的简单调用方式与项目中更工程化的封装方式。

可以把本专题当成「连接基础语法与真实网络项目」的一座桥梁：

- 向下：理解 socket / HTTP 等底层机制；
- 向上：为后续在 FastAPI、爬虫、系统对接等场景中写出更可靠的网络代码打基础。

---

## 6. 建议的自我练习

为了让网络编程真正变成你的「肌肉记忆」，可以尝试完成下面几个小练习：

1. 在 TCP 回声服务器基础上，增加「命令」支持：
   - 当客户端发送 `time` 时，返回服务器当前时间；
   - 当客户端发送 `quit` 时，主动关闭连接。
2. 编写一个小脚本，定期从某个公开 API 拉取数据（例如币价 / 天气），并把结果追加写入本地 CSV 文件。
3. 在 `run_simple_http_server` 的基础上增加简单日志：
   - 记录每次请求的路径和时间；
   - 写入到一个日志文件中（可以复用 `logging` 模块）。

完成这些练习后，再回头阅读 `03.项目实战` 中与网络相关的项目，你会对「请求是如何发出去的、服务是如何接收到的」有更加直观的理解。

