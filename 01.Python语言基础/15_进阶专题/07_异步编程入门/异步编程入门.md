# 异步编程入门

异步编程是Python 3.5+引入的重要特性，使用 `asyncio` 模块和 `async/await` 语法，能够高效处理IO密集型任务。

## 目录

1. [基础概念](#1-基础概念)
2. [async/await语法](#2-asyncawait语法)
3. [并发执行](#3-并发执行)
4. [异步模式](#4-异步模式)
5. [实战应用](#5-实战应用)

---

## 1. 基础概念

### 同步 vs 异步

```python
import asyncio
import time

# 同步（串行）- 总耗时3秒
def sync_tasks():
    time.sleep(1)  # 任务1
    time.sleep(1)  # 任务2
    time.sleep(1)  # 任务3

# 异步（并发）- 总耗时1秒
async def async_tasks():
    await asyncio.gather(
        asyncio.sleep(1),  # 任务1
        asyncio.sleep(1),  # 任务2
        asyncio.sleep(1),  # 任务3
    )
```

### 核心概念

| 术语 | 说明 |
|------|------|
| **协程** | 使用 `async def` 定义的函数 |
| **await** | 等待异步操作完成 |
| **事件循环** | 管理和执行异步任务的核心 |
| **任务** | 封装协程的可调度对象 |

---

## 2. async/await语法

### 定义异步函数

```python
async def fetch_data(url: str) -> dict:
    """异步函数（协程）"""
    # 模拟网络请求
    await asyncio.sleep(1)
    return {"url": url, "data": "..."}
```

### 运行异步函数

```python
# 方法1：使用 asyncio.run()（推荐）
result = asyncio.run(fetch_data("https://api.example.com"))

# 方法2：在已有事件循环中
async def main():
    result = await fetch_data("https://api.example.com")

asyncio.run(main())
```

### 常见错误

```python
# ❌ 错误：直接调用异步函数
data = fetch_data("url")  # 返回协程对象，不会执行

# ✅ 正确：使用 await
data = await fetch_data("url")

# ❌ 错误：在同步函数中使用 await
def sync_func():
    await fetch_data("url")  # SyntaxError

# ✅ 正确：在异步函数中使用 await
async def async_func():
    await fetch_data("url")
```

---

## 3. 并发执行

### gather - 并发运行多个协程

```python
# 同时执行多个任务
results = await asyncio.gather(
    fetch_data("url1"),
    fetch_data("url2"),
    fetch_data("url3"),
)
# 返回：[result1, result2, result3]
```

**特点**：
- 所有任务并发执行
- 等待所有任务完成
- 返回结果列表
- 任意任务失败则全部失败（除非设置 `return_exceptions=True`）

### create_task - 创建任务

```python
# 创建任务（立即开始执行）
task1 = asyncio.create_task(fetch_data("url1"))
task2 = asyncio.create_task(fetch_data("url2"))

# 稍后等待结果
result1 = await task1
result2 = await task2
```

### as_completed - 按完成顺序

```python
tasks = [fetch_data(url) for url in urls]

# 按完成顺序处理
for coro in asyncio.as_completed(tasks):
    result = await coro
    process(result)
```

### wait_for - 超时控制

```python
try:
    result = await asyncio.wait_for(
        fetch_data("url"),
        timeout=5.0  # 5秒超时
    )
except asyncio.TimeoutError:
    print("请求超时")
```

---

## 4. 异步模式

### 4.1 异步上下文管理器

```python
class AsyncDatabase:
    async def __aenter__(self):
        # 异步初始化
        await self.connect()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        # 异步清理
        await self.disconnect()

# 使用
async with AsyncDatabase() as db:
    await db.query("SELECT * FROM users")
```

### 4.2 异步迭代器

```python
class AsyncDataStream:
    async def __aiter__(self):
        return self

    async def __anext__(self):
        data = await self.fetch_next()
        if data is None:
            raise StopAsyncIteration
        return data

# 使用
async for item in AsyncDataStream():
    process(item)
```

### 4.3 异步生成器

```python
async def async_range(start, end):
    """异步生成器"""
    for i in range(start, end):
        await asyncio.sleep(0.1)
        yield i

# 使用
async for num in async_range(1, 10):
    print(num)
```

### 4.4 并发限制（信号量）

```python
# 限制最多3个并发请求
sem = asyncio.Semaphore(3)

async def limited_request(url):
    async with sem:  # 获取信号量
        return await fetch_data(url)

# 即使有10个任务，同时只运行3个
await asyncio.gather(*[limited_request(url) for url in urls])
```

### 4.5 异步队列

```python
queue = asyncio.Queue(maxsize=10)

# 生产者
async def producer():
    for i in range(100):
        await queue.put(f"item-{i}")

# 消费者
async def consumer():
    while True:
        item = await queue.get()
        await process(item)
        queue.task_done()
```

---

## 5. 实战应用

### 5.1 批量HTTP请求

```python
async def fetch_url(session, url):
    async with session.get(url) as response:
        return await response.text()

async def fetch_all(urls):
    async with aiohttp.ClientSession() as session:
        tasks = [fetch_url(session, url) for url in urls]
        return await asyncio.gather(*tasks)

# 使用
urls = ["https://api.example.com/1", ...]
results = asyncio.run(fetch_all(urls))
```

### 5.2 数据库操作

```python
import asyncpg  # PostgreSQL异步驱动

async def get_users():
    conn = await asyncpg.connect("postgresql://...")
    try:
        rows = await conn.fetch("SELECT * FROM users")
        return [dict(row) for row in rows]
    finally:
        await conn.close()
```

### 5.3 FastAPI异步路由

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/users/{user_id}")
async def get_user(user_id: int):
    # 异步数据库查询
    user = await db.fetch_user(user_id)
    return user

@app.post("/process")
async def process_data(data: dict):
    # 并发执行多个异步操作
    results = await asyncio.gather(
        validate_data(data),
        save_to_db(data),
        send_notification(data),
    )
    return {"status": "success"}
```

### 5.4 文件IO

```python
import aiofiles

async def read_file(filepath):
    async with aiofiles.open(filepath, "r") as f:
        content = await f.read()
    return content

async def write_file(filepath, content):
    async with aiofiles.open(filepath, "w") as f:
        await f.write(content)
```

---

## 6. 性能对比

### 适用场景

| 场景 | 同步 | 异步 | 多进程 |
|------|------|------|--------|
| **IO密集** | ❌ 慢 | ✅ 快 | ⚠️ 浪费 |
| **CPU密集** | ⚠️ 慢 | ❌ 无效 | ✅ 快 |
| **混合型** | ❌ 慢 | ⚠️ 部分改善 | ✅ 最佳 |

### 性能示例

```python
# 100个HTTP请求的对比
同步执行：100秒（每个1秒）
异步执行：1-2秒（并发）
性能提升：50-100倍
```

---

## 7. 最佳实践

### 7.1 异步函数命名

```python
# ✅ 推荐：明确表示异步
async def fetch_user_async(user_id):
    ...

# ⚠️ 可以但不明显
async def get_user(user_id):
    ...
```

### 7.2 错误处理

```python
async def safe_request(url):
    try:
        return await fetch_data(url)
    except asyncio.TimeoutError:
        return {"error": "timeout"}
    except Exception as e:
        return {"error": str(e)}
```

### 7.3 资源清理

```python
# ✅ 使用 async with 自动清理
async with session.get(url) as response:
    data = await response.text()

# ❌ 避免：手动管理容易遗漏
response = await session.get(url)
data = await response.text()
await response.close()
```

### 7.4 避免阻塞操作

```python
# ❌ 错误：在异步函数中使用同步阻塞操作
async def bad_example():
    time.sleep(1)  # 阻塞整个事件循环！

# ✅ 正确：使用异步版本
async def good_example():
    await asyncio.sleep(1)

# ✅ 正确：如果必须用同步操作，放到线程池
async def use_sync_code():
    loop = asyncio.get_event_loop()
    result = await loop.run_in_executor(None, blocking_function)
```

---

## 8. 与Java的对比

| Python | Java |
|--------|------|
| `async def` | CompletableFuture |
| `await` | `.get()` / `.join()` |
| `asyncio.gather()` | CompletableFuture.allOf() |
| `asyncio.create_task()` | executor.submit() |
| 协程 | Virtual Threads (Java 21+) |

---

## 9. 调试技巧

### 启用调试模式

```python
# 开启asyncio调试
asyncio.run(main(), debug=True)

# 或环境变量
PYTHONASYNCIODEBUG=1 python script.py
```

### 检测未等待的协程

```python
import warnings
warnings.simplefilter('always', ResourceWarning)

# 会警告未等待的协程
async def forgot_await():
    fetch_data("url")  # 忘记 await
```

---

## 10. 常见陷阱

### ⚠️ 陷阱1：忘记await

```python
# ❌ 错误
result = fetch_data("url")  # 得到协程对象，不是结果

# ✅ 正确
result = await fetch_data("url")
```

### ⚠️ 陷阱2：在循环中串行执行

```python
# ❌ 错误：串行执行（没有并发）
for url in urls:
    result = await fetch_data(url)

# ✅ 正确：并发执行
results = await asyncio.gather(*[fetch_data(url) for url in urls])
```

### ⚠️ 陷阱3：阻塞事件循环

```python
# ❌ 错误：阻塞整个事件循环
async def bad():
    time.sleep(1)  # 阻塞！其他协程无法运行

# ✅ 正确
async def good():
    await asyncio.sleep(1)  # 让出控制权
```

---

## 在本仓库中的应用

- **rbac_auth_service**：FastAPI 的 async 路由处理并发请求
- **integration_gateway_service**：异步 HTTP 客户端调用后端服务
- **log_audit_service**：异步接收和存储审计日志
- **前端 admin.html**：JavaScript 的 async/await 与 Python 异步的概念对比
- **综合练习**：参见 `15_进阶专题.md` 中"异步版本"进阶挑战

**Java 对比**：
- Python `asyncio` ≈ Java `CompletableFuture` / Reactor
- Python `async/await` ≈ Java Virtual Threads (JDK 21+)
- FastAPI async ≈ Spring WebFlux

## 相关资源

- [Python官方文档 - asyncio](https://docs.python.org/zh-cn/3/library/asyncio.html)
- [Python官方教程 - 协程](https://docs.python.org/zh-cn/3/library/asyncio-task.html)
- [aiohttp - 异步HTTP客户端](https://docs.aiohttp.org/)
- [FastAPI - 现代异步Web框架](https://fastapi.tiangolo.com/)
