# 标准库常用模块

Python标准库提供了丰富的工具模块，掌握这些模块可以大大提高开发效率。本专题介绍最常用的4个标准库模块。

## 目录

1. [datetime - 日期时间处理](#1-datetime)
2. [collections - 特殊容器](#2-collections)
3. [itertools - 迭代工具](#3-itertools)
4. [functools - 函数工具](#4-functools)
5. [实战应用](#5-实战应用)

---

## 1. datetime - 日期时间处理

### 核心类

| 类 | 说明 | 示例 |
|----|------|------|
| `datetime` | 日期+时间 | `datetime(2024, 1, 1, 10, 30)` |
| `date` | 日期 | `date(2024, 1, 1)` |
| `time` | 时间 | `time(10, 30, 0)` |
| `timedelta` | 时间间隔 | `timedelta(days=7)` |

### 常用操作

```python
from datetime import datetime, timedelta

# 获取当前时间
now = datetime.now()

# 格式化输出
now.strftime('%Y-%m-%d %H:%M:%S')  # "2024-01-01 10:30:00"

# 解析字符串
datetime.strptime('2024-01-01', '%Y-%m-%d')

# 日期运算
tomorrow = now + timedelta(days=1)
last_week = now - timedelta(weeks=1)

# 计算日期差
diff = date2 - date1
days = diff.days
```

### 格式化代码

| 代码 | 含义 | 示例 |
|------|------|------|
| `%Y` | 4位年份 | 2024 |
| `%m` | 月份(01-12) | 01 |
| `%d` | 日期(01-31) | 15 |
| `%H` | 小时(00-23) | 14 |
| `%M` | 分钟(00-59) | 30 |
| `%S` | 秒(00-59) | 45 |
| `%A` | 星期全名 | Monday |
| `%a` | 星期缩写 | Mon |

---

## 2. collections - 特殊容器

### 2.1 Counter - 计数器

快速统计可哈希对象的频率。

```python
from collections import Counter

words = ['apple', 'banana', 'apple', 'orange']
counter = Counter(words)
# Counter({'apple': 2, 'banana': 1, 'orange': 1})

# 最常见的N个
counter.most_common(2)  # [('apple', 2), ('banana', 1)]

# 计数器运算
counter1 + counter2  # 相加
counter1 - counter2  # 相减
```

**Java对比**：类似 `HashMap<T, Integer>` 手动计数。

### 2.2 defaultdict - 默认值字典

访问不存在的键时自动创建默认值。

```python
from collections import defaultdict

# 整数默认值
dd = defaultdict(int)
dd['a'] += 1  # 不会KeyError，默认为0

# 列表默认值（分组）
groups = defaultdict(list)
for name, class_name in students:
    groups[class_name].append(name)
```

**Java对比**：类似 `Map.computeIfAbsent()`。

### 2.3 namedtuple - 命名元组

创建具有命名字段的轻量级类。

```python
from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'])
p = Point(3, 4)
print(p.x, p.y)  # 3 4

# 不可变，性能好，适合只读数据
```

**Java对比**：类似 `record`（Java 14+）或简单的POJO。

### 2.4 deque - 双端队列

支持两端快速插入和删除的队列。

```python
from collections import deque

dq = deque([1, 2, 3])
dq.append(4)      # 右端添加
dq.appendleft(0)  # 左端添加
dq.pop()          # 右端删除
dq.popleft()      # 左端删除

# 限制长度（自动删除旧元素）
limited = deque(maxlen=5)
```

**Java对比**：类似 `ArrayDeque<T>`。

---

## 3. itertools - 迭代工具

提供高效的迭代器工具函数。

### 无限迭代器

| 函数 | 说明 | 示例 |
|------|------|------|
| `count(start, step)` | 无限计数 | `count(10, 2)` → 10, 12, 14, ... |
| `cycle(iterable)` | 循环迭代 | `cycle('ABC')` → A, B, C, A, B, ... |
| `repeat(elem, n)` | 重复元素 | `repeat('A', 3)` → A, A, A |

### 组合迭代器

| 函数 | 说明 | 示例 |
|------|------|------|
| `chain(*iterables)` | 连接多个迭代器 | `chain([1,2], [3,4])` → 1,2,3,4 |
| `combinations(it, r)` | 组合 | `combinations('ABC', 2)` → AB,AC,BC |
| `permutations(it, r)` | 排列 | `permutations('ABC', 2)` → AB,AC,BA,BC,CA,CB |
| `product(*its)` | 笛卡尔积 | `product('AB', '12')` → A1,A2,B1,B2 |

### 其他有用工具

```python
from itertools import groupby, accumulate, islice

# groupby - 分组（需先排序）
data.sort(key=lambda x: x['category'])
for key, group in groupby(data, key=lambda x: x['category']):
    print(f"{key}: {list(group)}")

# accumulate - 累积
list(accumulate([1, 2, 3, 4]))  # [1, 3, 6, 10]

# islice - 切片迭代器
list(islice(count(), 5))  # [0, 1, 2, 3, 4]
```

---

## 4. functools - 函数工具

函数式编程辅助工具。

### 4.1 reduce - 归约

将二元函数累积应用到序列。

```python
from functools import reduce

numbers = [1, 2, 3, 4, 5]
sum_result = reduce(lambda x, y: x + y, numbers)  # 15
product = reduce(lambda x, y: x * y, numbers)      # 120
```

**Java对比**：类似 Stream API 的 `reduce()`。

### 4.2 partial - 偏函数

固定函数的部分参数。

```python
from functools import partial

def power(base, exponent):
    return base ** exponent

square = partial(power, exponent=2)
cube = partial(power, exponent=3)

square(5)  # 25
cube(5)    # 125
```

**用途**：减少重复参数，创建特化版本。

### 4.3 lru_cache - LRU缓存

自动缓存函数结果（最近最少使用算法）。

```python
from functools import lru_cache

@lru_cache(maxsize=128)
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

fibonacci(100)  # 极快，使用缓存
fibonacci.cache_info()  # 查看缓存统计
fibonacci.cache_clear()  # 清空缓存
```

**性能提升**：递归函数速度可提升数百倍。

### 4.4 wraps - 装饰器辅助

保留被装饰函数的元信息。

```python
from functools import wraps

def my_decorator(func):
    @wraps(func)  # 保留func的__name__、__doc__等
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper
```

### 4.5 total_ordering - 完整排序

只需实现 `__eq__` 和一个比较方法，自动生成其他比较方法。

```python
from functools import total_ordering

@total_ordering
class Student:
    def __init__(self, name, score):
        self.name = name
        self.score = score

    def __eq__(self, other):
        return self.score == other.score

    def __lt__(self, other):
        return self.score < other.score

    # __le__, __gt__, __ge__ 自动生成
```

---

## 5. 实战应用

### 5.1 日志分析示例

```python
from collections import Counter, defaultdict
from datetime import datetime
from itertools import groupby

# 解析日志
logs = parse_logs(log_file)

# 统计各级别数量
level_count = Counter(log['level'] for log in logs)

# 按日期分组
logs_by_date = defaultdict(list)
for log in logs:
    date_key = log['datetime'].date()
    logs_by_date[date_key].append(log)

# 找出高频错误
error_messages = [log['message'] for log in logs if log['level'] == 'ERROR']
common_errors = Counter(error_messages).most_common(10)
```

### 5.2 数据处理管道

```python
from itertools import chain, groupby
from functools import reduce

# 连接多个数据源
all_data = chain(source1, source2, source3)

# 分组聚合
data.sort(key=lambda x: x['category'])
aggregated = {
    key: reduce(lambda a, b: a + b['value'], group, 0)
    for key, group in groupby(data, key=lambda x: x['category'])
}
```

### 5.3 缓存优化

```python
from functools import lru_cache

@lru_cache(maxsize=1000)
def expensive_database_query(user_id):
    # 数据库查询
    return db.query(f"SELECT * FROM users WHERE id={user_id}")

# 第一次查询数据库，之后使用缓存
user = expensive_database_query(123)
```

---

## 6. 最佳实践

### 何时使用

| 需求 | 使用模块 |
|------|----------|
| 统计频率 | `Counter` |
| 分组数据 | `defaultdict(list)` |
| 日期计算 | `datetime` + `timedelta` |
| 生成组合/排列 | `itertools.combinations/permutations` |
| 函数缓存 | `@lru_cache` |
| 固定参数 | `partial` |
| 双端队列 | `deque` |

### 性能提示

1. **Counter vs 手动计数**：Counter更快更简洁
2. **deque vs list**：两端操作用deque（O(1) vs O(n)）
3. **lru_cache**：对纯函数效果最好
4. **itertools**：内存友好，延迟计算

### 与Java的对比

| Python | Java |
|--------|------|
| `Counter` | `HashMap<T, Integer>` + 手动计数 |
| `defaultdict` | `Map.computeIfAbsent()` |
| `namedtuple` | `record` 或 POJO |
| `deque` | `ArrayDeque<T>` |
| `itertools` | Stream API部分功能 |
| `lru_cache` | Guava的`CacheBuilder` |

---

## 7. 练习建议

1. **日期处理**：计算两个日期之间的工作日数
2. **数据统计**：分析文本文件的词频前10名
3. **缓存应用**：优化递归函数性能
4. **组合问题**：生成所有可能的密码组合

## 在本仓库中的应用

- **rbac_auth_service**：`datetime` 处理 Token 过期时间、用户创建时间
- **log_audit_service**：`Counter` 统计日志操作类型、`defaultdict` 分组聚合
- **日志分析项目**：`itertools.groupby` 按日期分组、`functools.lru_cache` 缓存
- **销售统计项目**：`Counter` 统计销售数据、`namedtuple` 表示记录
- **综合练习**：参见 `15_进阶专题.md` 中的"审计日志分析与报表生成"练习

## 相关资源

- [Python官方文档 - datetime](https://docs.python.org/zh-cn/3/library/datetime.html)
- [Python官方文档 - collections](https://docs.python.org/zh-cn/3/library/collections.html)
- [Python官方文档 - itertools](https://docs.python.org/zh-cn/3/library/itertools.html)
- [Python官方文档 - functools](https://docs.python.org/zh-cn/3/library/functools.html)
