# 08_调试与性能分析

> 目标：掌握常用调试工具（pdb / logging）与性能分析工具（timeit / cProfile），并在小项目中快速定位问题与性能热点。

## 1. 快速调试：pdb / breakpoint()

```python
def calc(x, y):
    breakpoint()  # 等价于 import pdb; pdb.set_trace()
    return x / y

calc(10, 2)
```

- 常用命令：`n` 单步、`s` 进入、`c` 继续、`l` 查看代码、`p 变量`、`q` 退出。
- 建议：调试结束后移除断点或用环境变量控制（如 `PYTHONBREAKPOINT=0` 关闭）。

## 2. logging 取代 print

```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s - %(message)s",
)
logger = logging.getLogger(__name__)

logger.info("启动应用")
logger.warning("配置缺失，使用默认值")
logger.error("请求失败", exc_info=True)
```

要点：
- 统一格式与级别；生产环境可切换为文件或 JSON 日志。
- 在本仓库中，网关/审计/日志侦探等服务均可使用同一日志格式便于排查。

## 3. 快速基准：timeit

```python
import timeit

def sum_loop(n):
    return sum(range(n))

duration = timeit.timeit("sum_loop(100000)", globals=globals(), number=100)
print(f"耗时：{duration:.4f}s")
```

适合对小片段进行微基准，避免受启动噪声影响可多次运行取平均。

## 4. 函数级性能分析：cProfile + pstats

```python
import cProfile
import pstats
from demo_debug_profiling import heavy_compute

profile = cProfile.Profile()
profile.enable()
heavy_compute(5000)
profile.disable()

stats = pstats.Stats(profile).sort_stats("cumulative")
stats.print_stats(10)  # 查看累计耗时 Top 10
```

要点：
- `cumulative` 排序适合找总耗时热点；`time` 排序看单次调用耗时。
- 结合 `pstats.Stats(...).strip_dirs()` 可去掉长路径，输出更简洁。

## 5. pytest 与覆盖率（quick ref）

```bash
pytest -q                      # 运行测试
pytest -k profile -q           # 按关键词过滤
pytest --maxfail=1 --lf        # 失败即停 & 只跑上次失败用例
pytest --cov=. --cov-report=term-missing
```

建议：为性能敏感函数写回归用例，结合 timeit/cProfile 结果做优化。

## 6. 配套示例
- 运行：`python 01.Python语言基础/15_进阶专题/08_调试与性能分析/demo_debug_profiling.py`
- 内容：logging 基础输出、timeit 基准对比、cProfile 统计 Top10。

## 7. 推荐实践
- 本地先用 timeit 做微基准，发现热点后用 cProfile 定位函数级耗时。
- 重要路径加 logging（info/ warning/ error），并保留 `exc_info=True` 便于追踪。
- 与前端/服务联调时，可在网关和下游服务上用统一日志格式 + trace id。***
