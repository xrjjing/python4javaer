# 高级并发技巧：threading.local 与进程池

## 1. 线程本地存储 threading.local

```python
import threading

local_ctx = threading.local()

def worker(name):
    local_ctx.user = name
    print(threading.current_thread().name, local_ctx.user)

threads = [threading.Thread(target=worker, args=(f"user{i}",)) for i in range(3)]
for t in threads:
    t.start()
for t in threads:
    t.join()
```

要点：每个线程看到的 `local_ctx.user` 互不干扰，适合存放请求上下文、trace id 等。

## 2. 进程池 multiprocessing.Pool

```python
from multiprocessing import Pool

def square(n: int) -> int:
    return n * n

if __name__ == "__main__":
    with Pool(processes=2) as pool:
        results = pool.map(square, [1, 2, 3, 4])
        print(results)
```

要点：
- Windows/macOS 需放在 `if __name__ == "__main__"` 下。
- 适合 CPU 密集型任务；IO 密集优先线程/async。

## 3. 线程池与进程池何时选
- CPU 密集：multiprocessing.Pool / ProcessPoolExecutor
- IO 密集：ThreadPoolExecutor / asyncio + httpx
- 需要线程内上下文：threading.local 保持请求信息

## 4. 本仓库应用示例
- 网关/审计可在中间件设置 trace id 到 threading.local，日志打印自动带出。
- 批处理或数据清洗脚本可用进程池并行分片处理大文件。

## 5. 配套示例
- 运行：`python 01.Python语言基础/15_进阶专题/06_多线程与多进程/demo_concurrency_adv.py`
